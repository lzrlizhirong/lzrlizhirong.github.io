<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>八阿哥李四 | BugLess</title>
  <subtitle>日积跬步,志在千里</subtitle>
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://lzrlizhirong.github.io/"/>
  <updated>2017-02-15T03:43:50.000Z</updated>
  <id>http://lzrlizhirong.github.io/</id>
  
  <author>
    <name>李志荣</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>提高命令效率之利器oh-my-zsh</title>
    <link href="http://lzrlizhirong.github.io/2017/02/15/%E6%8F%90%E9%AB%98%E5%91%BD%E4%BB%A4%E6%95%88%E7%8E%87%E4%B9%8B%E5%88%A9%E5%99%A8oh-my-zsh/"/>
    <id>http://lzrlizhirong.github.io/2017/02/15/提高命令效率之利器oh-my-zsh/</id>
    <published>2017-02-15T03:35:43.000Z</published>
    <updated>2017-02-15T03:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我知道了zsh，并体验了5分钟的时候，我决定将zsh作为我的默认 shell 终端。为什么？效率提高实在是太简单啦！<br>从这里你可能也就知道了zsh是 shell 的一种，当然还包括目前估计是你默认的bash ，输入下面的命令，就能看到你的系统中提供了多少的 shell ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /etc/shells</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>前人已经有好多使用zsh的，所以这类的文章也很多，包括怎么安装、使用技巧等等，请看：</p>
<ul>
<li><a href="http://macshuo.com/?p=676" target="_blank" rel="external">池建强-终极 Shell</a></li>
<li><a href="http://lostjs.com/2012/09/27/zsh/" target="_blank" rel="external">使用 zsh 的九个理由</a></li>
<li><a href="http://www.rayninfo.co.uk/tips/zshtips.html" target="_blank" rel="external">ZSH Tips by ZZapper-很全的zsh命令汇总</a></li>
<li><a href="http://foocoder.com/blog/wo-zai-yong-de-macruan-jian-2.html/" target="_blank" rel="external">我在用的mac软件(2)-终端环境之zsh和z(*nix都适用) 详细介绍作者使用的一些命令，通俗简单。</a></li>
<li><a href="https://webdevstudios.com/2015/02/10/a-beginners-guide-to-the-best-command-line-tools/" target="_blank" rel="external">a-beginners-guide-to-the-best-command-line-tools</a></li>
</ul>
<p>我所使用的几个 plugin 如下 ：</p>
<ul>
<li>autojump</li>
<li>git</li>
<li>colored-man</li>
<li>colorize</li>
<li>copydir</li>
<li>command-not-found</li>
<li>history</li>
<li>sublime</li>
<li>brew</li>
<li><em><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview" target="_blank" rel="external">挑选你自己的 plugin……</a></em></li>
<li><em><a href="https://github.com/unixorn/awesome-zsh-plugins" target="_blank" rel="external">更多plugin查看 - awesome-zsh-plugins</a></em></li>
</ul>
<p>使用方法很简单，在~/.zshrc文件的plugin下面添加上你想要的插件名称就ok<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plugins=(git autojump colored-man colorize copydir history sublime command-not-found)</div></pre></td></tr></table></figure></p>
<p>如果你想要定制化你自己的zsh，访问官网 <a href="http://ohmyz.sh/" target="_blank" rel="external">http://ohmyz.sh/</a> ，上面有你需要的 plugin、theme，有意思的还有T恤……</p>
<p>感觉默认主题不适合你，可以访问 <a href="https://github.com/unixorn/awesome-zsh-plugins#themes" target="_blank" rel="external">https://github.com/unixorn/awesome-zsh-plugins#themes</a> 查看更多的主题</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我知道了zsh，并体验了5分钟的时候，我决定将zsh作为我的默认 shell 终端。为什么？效率提高实在是太简单啦！&lt;br&gt;从这里你可能也就知道了zsh是 shell 的一种，当然还包括目前估计是你默认的bash ，输入下面的命令，就能看到你的系统中提供了多少的 shell ：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;cat /etc/shells&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://lzrlizhirong.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://lzrlizhirong.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="oh-my-zsh" scheme="http://lzrlizhirong.github.io/tags/oh-my-zsh/"/>
    
  </entry>
  
  <entry>
    <title>iterm2技巧</title>
    <link href="http://lzrlizhirong.github.io/2017/02/15/iterm2%E6%8A%80%E5%B7%A7/"/>
    <id>http://lzrlizhirong.github.io/2017/02/15/iterm2技巧/</id>
    <published>2017-02-15T03:27:04.000Z</published>
    <updated>2017-02-15T03:33:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mac 上最适合开发使用的终极终端 iTerm2，比自带的 term 终端有很多特性，比如竖屏操作、历史剪贴板、选中即复制、搜索高亮自动复制搜索内容、像 secureRT 样子的复制会话，记住密码登录，tux 集成等等。<br>至于 Shell，一定要选则 zsh ，Mac 下已经自带，安装 oh my zsh 不用复杂的配置即可使用<br>一些常用的提升效率的快捷键和插件整理如下:<br><a id="more"></a></p>
<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>官方的介绍特点:</p>
<ul>
<li>⌘ + 数字在各 tab 标签直接来回切换</li>
<li>选择即复制 + 鼠标中键粘贴，这个很实用</li>
<li>⌘ + f 所查找的内容会被自动复制</li>
<li>⌘ + d 横着分屏 / ⌘ + shift + d 竖着分屏</li>
<li>⌘ + r = clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏</li>
<li>ctrl + u 清空当前行，无论光标在什么位置</li>
<li>输入开头命令后 按 ⌘ + ; 会自动列出输入过的命令</li>
<li>⌘ + shift + h 会列出剪切板历史</li>
<li>可以在 Preferences &gt; keys 设置全局快捷键调出 iterm，这个也可以用过 Alfred 实现</li>
</ul>
<p>一些常用的快捷键如下:</p>
<ul>
<li>新建标签：command + t</li>
<li>关闭标签：command + w</li>
<li>切换标签：command + 数字 command + 左右方向键</li>
<li>切换全屏：command + enter</li>
<li>查找：command + f</li>
<li>垂直分屏：command + d</li>
<li>水平分屏：command + shift + d</li>
<li>切换屏幕：command + option + 方向键 command + [ 或 command + ]</li>
<li>查看历史命令：command +</li>
<li>查看剪贴板历史：command + shift + h</li>
<li>清除当前行：ctrl + u</li>
<li>到行首：ctrl + a</li>
<li>到行尾：ctrl + e</li>
<li>前进后退：ctrl + f/b (相当于左右方向键)</li>
<li>上一条命令：ctrl + p</li>
<li>搜索命令历史：ctrl + r</li>
<li>删除当前光标的字符：ctrl + d</li>
<li>删除光标之前的字符：ctrl + h</li>
<li>删除光标之前的单词：ctrl + w</li>
<li>删除到文本末尾：ctrl + k</li>
<li>交换光标处文本：ctrl + t</li>
<li>清屏1：command + r</li>
<li>清屏2：ctrl + l</li>
</ul>
<h1 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h1><p>一些插件能显著提高效率，自己使用的一些在下面，方法很简单，在~/.zshrc文件的plugin 下面添加上你想要的插件名称就ok，oh-my-sh 自带了很多插件，可以通过 ls ~/.oh-my-zsh/plugins 来查看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plugins=(git-extras git mvn svn osx brew brew-cask npm  colored-man colorize copydir history sublime command-not-found zsh-syntax-highlighting Z)</div></pre></td></tr></table></figure></p>
<ul>
<li>git：当你处于一个 git 受控的目录下时，Shell 会明确显示 「git」和 branch，如上图所示，另外对 git 很多命令进行了简化，例如 gco=’git checkout’、gd=’git diff’、gst=’git status’、g=’git’等等，熟练使用可以大大减少 git 的命令长度，命令内容可以参考~/.oh-my-zsh/plugins/git/git.plugin.zsh</li>
<li>textmate：mr可以创建 ruby 的框架项目，tm finename 可以用 textmate 打开指定文件。</li>
<li>osx：tab 增强，quick-look filename 可以直接预览文件，man-preview grep 可以生成 grep手册 的pdf 版本等。</li>
<li>git-extras: Git extras 工具与 zsh 的继承，很方便，在 git 仓库目录下试试git summary即可看到整个仓库的汇总信息。</li>
<li>sublime : 此插件能够在终端下使用命令stt 在 SublimeText 中打开当前文件夹，使用 subl 或者 st 来编辑某个特定文件，比如 st 1.txt，当然前提你得安装了 SublimeText。</li>
<li>zsh-syntax-highlighting: 让你终端的每一条命令智能显示颜色，就像在 IDE 里面写代码一样，强烈推荐，安装及介绍参考 GitHub</li>
<li>z : Z is awesome ，让你在不同的目录中快速跳转，比如我想访问 ~/work/code/project/testApp ，只要是之前访问过，直接输入z testApp 按 tab 键直接显示完整目录，按 enter 键直接进入当前目录，即使只输入了z testa 也能完成同样的工作，大大提升效率，此插件是自带的可以直接使用。</li>
<li>ag: 终端里面快速搜索当前目录下所有文件中所匹配的关键字的命令，类似与 awk，但是速度极快，速度极快，速度极快，使用brew install ，其实就是组件 the_silver_searcher ，详细参考地址 GitHub 。</li>
<li>tree : mac 下的 tree 命令，方便排查问题，直接 brew install tree即可。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac 上最适合开发使用的终极终端 iTerm2，比自带的 term 终端有很多特性，比如竖屏操作、历史剪贴板、选中即复制、搜索高亮自动复制搜索内容、像 secureRT 样子的复制会话，记住密码登录，tux 集成等等。&lt;br&gt;至于 Shell，一定要选则 zsh ，Mac 下已经自带，安装 oh my zsh 不用复杂的配置即可使用&lt;br&gt;一些常用的提升效率的快捷键和插件整理如下:&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://lzrlizhirong.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://lzrlizhirong.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="iterm2" scheme="http://lzrlizhirong.github.io/tags/iterm2/"/>
    
  </entry>
  
  <entry>
    <title>Mac键盘快捷键</title>
    <link href="http://lzrlizhirong.github.io/2017/02/15/Mac%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://lzrlizhirong.github.io/2017/02/15/Mac键盘快捷键/</id>
    <published>2017-02-15T02:50:22.000Z</published>
    <updated>2017-02-15T03:27:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>要使用键盘快捷键，请按住一个或多个修饰键，同时按快捷键的最后一个键。例如，要使用快捷键 Command-C（拷贝），请按住 Command 键并按 C 键，然后同时松开这两个键。Mac 菜单和键盘通常使用某些按键的符号，其中包括以下修饰键：</p>
<ul>
<li>Command ⌘</li>
<li>Shift ⇧</li>
<li>Option ⌥</li>
<li>Control ⌃</li>
<li>Caps Lock ⇪</li>
<li>Fn</li>
</ul>
<a id="more"></a>
<p>如果你使用的是 Windows PC 专用键盘，请用 Alt 键代替 Option 键，用 Windows 标志键代替 Command 键。有些 Mac 键盘在顶行中设有特殊按键，快捷键中也会用到它们；这些按键上有音量图标、显示屏亮度图标和其他功能图标。按下图标键可执行相应功能，将其与 Fn 键组合可用作 F1、F2、F3 或其他标准功能键。 </p>
<h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">快捷键     | 描述</div><div class="line">Command-X | 剪切：删除所选项并将其拷贝到剪贴板。</div><div class="line">Command-C | 将所选项拷贝到剪贴板。这同样适用于 Finder 中的文件。</div><div class="line">Command-V | 将剪贴板的内容粘贴到当前文稿或 app 中。这同样适用于 Finder 中的文件。</div><div class="line">Command-Z | 撤销前一个命令。随后你可以按 Command-Shift-Z 来重做，从而反向执行撤销命令。在某些 app 中，你可以撤销和重做多个命令。</div><div class="line">Command-A | 全选各项。</div><div class="line">Command-F | 查找：打开“查找”窗口，或在文稿中查找项目。</div><div class="line">Command-G | 再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Command-Shift-G。</div><div class="line">Command-H | 隐藏最前面的 app 的窗口。要查看最前面的 app 但隐藏所有其他 app，请按 Command-Option-H。</div><div class="line">Command-M | 将最前面的窗口最小化至 Dock。要最小化最前面的 app 的所有窗口，请按 Command-Option-M。</div><div class="line">Command-N | 新建：打开一个新文稿或窗口。</div><div class="line">Command-O | 打开所选项，或打开一个对话框以选择要打开的文件。</div><div class="line">Command-P | 打印当前文稿。</div><div class="line">Command-S | 存储当前文稿。</div><div class="line">Command-W | 关闭最前面的窗口。要关闭该 app 的所有窗口，请按 Command-Option-W。</div><div class="line">Command-Q | 退出 app。</div><div class="line">空格键     | 快速查看：使用快速查看预览所选项。</div><div class="line">Command-Tab	         | 切换 app：在打开的 app 中切换到下一个最近使用的 app。</div><div class="line">Shift-Command-3          | 屏幕快照：拍摄整个屏幕的屏幕快照。了解更多屏幕快照快捷键。</div><div class="line">Command-逗号 (,)          | 偏好设置：打开最前面的 app 的偏好设置。</div><div class="line">Option-Command-Esc	  | 强制退出：选择要强制退出的 app。或者，按住 Command-Shift-Option-Esc 3 秒钟来仅强制最前面的 app 退出。</div><div class="line">Command–空格键	          | Spotlight：显示或隐藏 Spotlight 搜索栏。要从 Finder 窗口执行 Spotlight 搜索，请按 Command–Option–空格键。如果你使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示 Spotlight。</div><div class="line">Shift-Command-波浪号 (~)	  | 切换窗口：切换到最前端应用中下一个最近使用的窗口。</div></pre></td></tr></table></figure>
<h1 id="文档快捷键"><a href="#文档快捷键" class="headerlink" title="文档快捷键"></a>文档快捷键</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">  快捷键         | 	描述</div><div class="line">Command-B	| 以粗体显示所选文本，或者打开或关闭粗体显示功能。 </div><div class="line">Command-I	| 以斜体显示所选文本，或者打开或关闭斜体显示功能。</div><div class="line">Command-U	| 对所选文本加下划线，或者打开或关闭加下划线功能。</div><div class="line">Command-T	| 显示或隐藏“字体”窗口.</div><div class="line">Command-D	| 从“打开”对话框或“存储”对话框中选择“桌面”文件夹。</div><div class="line">Control-Command-D	| 显示或隐藏所选字词的定义。</div><div class="line">Shift-Command-冒号 (:)	| 显示“拼写和语法”窗口。</div><div class="line">Command-分号 (;)	| 查找文稿中拼写错误的字词。</div><div class="line">Option-Delete	| 删除插入点左边的字词。</div><div class="line">Control-H	| 删除插入点左边的字符。也可以使用 Delete 键。</div><div class="line">Control-D	| 删除插入点右边的字符。也可以使用 Fn-Delete。</div><div class="line">Fn-Delete	| 在没有向前删除   键的键盘上向前删除。也可以使用 Control-D。</div><div class="line">Control-K	| 删除插入点与行或段落末尾处之间的文本。</div><div class="line">Command-Delete	| 在包含“删除”或“不存储”按钮的对话框中选择“删除”或“不存储”。</div><div class="line">Fn–上箭头	        | 向上翻页：向上滚动一页。 </div><div class="line">Fn–下箭头	        | 向下翻页：向下滚动一页。</div><div class="line">Fn–左箭头	        | 开头：滚动到文稿开头。</div><div class="line">Fn–右箭头	        | 结尾：滚动到文稿末尾。</div><div class="line">Command–上箭头	| 将插入点移至文稿开头。</div><div class="line">Command–下箭头	| 将插入点移至文稿末尾。</div><div class="line">Command–左箭头	| 将插入点移至当前行的行首。</div><div class="line">Command–右箭头	| 将插入点移至当前行的行尾。</div><div class="line">Option–左箭头	| 将插入点移至上一字词的词首。</div><div class="line">Option–右箭头	| 将插入点移至下一字词的词尾。</div><div class="line">Shift–Command–上箭头           | 选中插入点与文稿开头之间的文本。</div><div class="line">Shift–Command–下箭头           | 选中插入点与文稿末尾之间的文本。</div><div class="line">Shift–Command–左箭头           | 选中插入点与当前行行首之间的文本。</div><div class="line">Shift–Command–右箭头           | 选中插入点与当前行行尾之间的文本。</div><div class="line">Shift–上箭头 | 将文本选择范围扩展到上一行相同水平位置的最近字符处。</div><div class="line">Shift–下箭头 | 将文本选择范围扩展到下一行相同水平位置的最近字符处。</div><div class="line">Shift–左箭头 | 将文本选择范围向左扩展一个字符。</div><div class="line">Shift–右箭头 | 将文本选择范围向右扩展一个字符。</div><div class="line">Option–Shift–上箭头	| 将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。</div><div class="line">Option–Shift–下箭头	| 将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。</div><div class="line">Option–Shift–左箭头	| 将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。</div><div class="line">Option–Shift–右箭头	| 将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。</div><div class="line">Control-A	| 移至行或段落的开头。</div><div class="line">Control-E	| 移至行或段落的末尾。</div><div class="line">Control-F	| 向前移动一个字符。</div><div class="line">Control-B	| 向后移动一个字符。</div><div class="line">Control-L	| 将光标或所选内容置于可见区域中央。</div><div class="line">Control-P	| 上移一行。</div><div class="line">Control-N	| 下移一行。</div><div class="line">Control-O	| 在插入点后插入一行。</div><div class="line">Control-T	| 将插入点后面的字符与插入点前面的字符交换。</div><div class="line">Command–左花括号 (&#123;)	| 左对齐。</div><div class="line">Command–右花括号 (&#125;)	| 右对齐。</div><div class="line">Shift–Command–竖线 | 居中对齐。</div><div class="line">Option-Command-F	  | 前往搜索栏。 </div><div class="line">Option-Command-T	  | 显示或隐藏应用中的工具栏。</div><div class="line">Option-Command-C	  | 拷贝样式：将所选项的格式设置拷贝到剪贴板。</div><div class="line">Option-Command-V	  | 粘贴样式：将拷贝的样式应用到所选项。</div><div class="line">Option-Shift-Command-V	| 粘贴并匹配样式：将周围内容的样式应用到粘贴在该内容中的项目。</div><div class="line">Option-Command-I	   | 显示或隐藏检查器窗口。</div><div class="line">Shift-Command-P	   | 页面设置：显示用于选择文稿设置的窗口。</div><div class="line">Shift-Command-S	   | 显示“存储为”对话框或复制当前文稿。</div><div class="line">Shift–Command–减号 (-)   | 	缩小所选项。</div><div class="line">Shift–Command–加号 (+)   |	放大所选项。Command–等号 (=) 可执行相同的功能。</div><div class="line">Shift–Command–问号 (?)   |	打开“帮助”菜单。</div></pre></td></tr></table></figure>
<h1 id="截图操作"><a href="#截图操作" class="headerlink" title="截图操作"></a>截图操作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">截图快捷键                    | 含义</div><div class="line">command+shift+3             | 全屏截图，保存截图到桌面文件</div><div class="line">command+shift+4             | 鼠标选定区域截图，保存截图到桌面文件</div><div class="line">command+shift+control+3     | 全屏截图，保存到剪贴板</div><div class="line">command+shift+control+4     | 鼠标选定区域截图，保存到剪贴板</div><div class="line">command+shift(+control)+4   | 然后按下空格键，鼠标变成小相机，选择某一窗口后点击鼠标左键对单个窗口截图。不必担心其它窗口的遮挡。</div></pre></td></tr></table></figure>
<h1 id="Finder-快捷键"><a href="#Finder-快捷键" class="headerlink" title="Finder 快捷键"></a>Finder 快捷键</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">快捷键           |  描述</div><div class="line">Command-D	| 复制所选文件。</div><div class="line">Command-E	| 推出所选磁盘或宗卷。</div><div class="line">Command-F	| 在 Finder 窗口中开始 Spotlight 搜索。</div><div class="line">Command-I	| 显示所选文件的“显示简介”窗口。</div><div class="line">Shift-Command-C	| 打开“电脑”窗口。</div><div class="line">Shift-Command-D	| 打开“桌面”文件夹。</div><div class="line">Shift-Command-F	| 打开“我的所有文件”窗口。</div><div class="line">Shift-Command-G	| 打开“前往文件夹”窗口。</div><div class="line">Shift-Command-H	| 打开当前 macOS 用户帐户的个人文件夹。</div><div class="line">Shift-Command-I	| 打开 iCloud Drive。</div><div class="line">Shift-Command-K	| 打开“网络”窗口。</div><div class="line">Option-Command-L| 	打开“下载”文件夹。</div><div class="line">Shift-Command-O	| 打开“文稿”文件夹。</div><div class="line">Shift-Command-R	| 打开“AirDrop”窗口。</div><div class="line">Shift-Command-T	| 将所选的 Finder 项目添加到 Dock（OS X Mountain Lion 或较早版本）</div><div class="line">Control-Shift-Command-T| 	将所选的 Finder 项目添加到 Dock（OS X Mavericks 或更高版本）</div><div class="line">Shift-Command-U	| 打开“实用工具”文件夹。</div><div class="line">Option-Command-D	| 显示或隐藏 Dock。即使您未打开 Finder，此快捷键通常也有效。</div><div class="line">Control-Command-T	| 将所选项添加到边栏（OS X Mavericks 或更高版本）。</div><div class="line">Option-Command-P	| 隐藏或显示 Finder 窗口中的路径栏。</div><div class="line">Option-Command-S	| 隐藏或显示 Finder 窗口中的边栏。</div><div class="line">Command–斜线 (/) |	隐藏或显示 Finder 窗口中的状态栏。</div><div class="line">Command-J	| 调出“显示”选项。</div><div class="line">Command-K	| 打开“连接服务器”窗口。</div><div class="line">Command-L	| 为所选项制作替身。</div><div class="line">Command-N	| 打开一个新的 Finder 窗口。</div><div class="line">Shift-Command-N	| 新建文件夹。</div><div class="line">Option-Command-N |	新建智能文件夹。</div><div class="line">Command-R	| 显示所选替身的原始文件。</div><div class="line">Command-T	| 在当前 Finder 窗口中打开单个标签时显示或隐藏标签栏。</div><div class="line">Shift-Command-T	 | 显示或隐藏 Finder 标签。</div><div class="line">Option-Command-T	| 在当前 Finder 窗口中打开单个标签时显示或隐藏工具栏。</div><div class="line">Option-Command-V	| 移动：将剪贴板中的文件从其原始位置移动到当前位置。</div><div class="line">Option-Command-Y	| 显示所选文件的快速查看幻灯片显示。</div><div class="line">Command-Y| 	使用“快速查看”预览所选文件。</div><div class="line">Command-1| 	以图标方式显示 Finder 窗口中的项目。</div><div class="line">Command-2| 	以列表方式显示 Finder 窗口中的项目。</div><div class="line">Command-3| 	以分栏方式显示 Finder 窗口中的项目。 </div><div class="line">Command-4| 	以 Cover Flow 方式显示 Finder 窗口中的项目。</div><div class="line">Command–左中括号 ([)	| 前往上一文件夹。</div><div class="line">Command–右中括号 (])	| 前往下一文件夹。</div><div class="line">Command–上箭头	| 打开包含当前文件夹的文件夹。</div><div class="line">Command–Control–上箭头	| 在新窗口中打开包含当前文件夹的文件夹。</div><div class="line">Command–下箭头	| 打开所选项。</div><div class="line">Command–Mission Control	| 显示桌面。即使您未打开 Finder，此快捷键也有效。</div><div class="line">Command–调高亮度	| 开启或关闭目标显示器模式。</div><div class="line">Command–调低亮度	| 当 Mac 连接到多个显示器时打开或关闭显示器镜像功能。</div><div class="line">右箭头 	| 打开所选文件夹。此快捷键仅在列表视图中有效。</div><div class="line">左箭头	| 关闭所选文件夹。此快捷键仅在列表视图中有效。</div><div class="line">Option-连按 | 	在单独窗口中打开文件夹，并关闭当前窗口。</div><div class="line">Command-连按	| 在单独标签或窗口中打开文件夹。</div><div class="line">Command-Delete	| 将所选项移到废纸篓。</div><div class="line">Shift-Command-Delete| 	清倒废纸篓。</div><div class="line">Option-Shift-Command-Delete| 	清倒废纸篓（不显示确认对话框）。</div><div class="line">Command-Y	| 使用“快速查看”预览文件。</div><div class="line">Option–调高亮度	| 打开“显示器”偏好设置。此快捷键可与任一亮度键搭配使用。</div><div class="line">Option–Mission Control	| 打开“Mission Control”偏好设置。</div><div class="line">Option–调高音量	| 打开“声音”偏好设置。此快捷键可与任一音量键搭配使用。</div><div class="line">拖移时按 Command 键| 	将拖移的项目移到其他宗卷或位置。拖移项目时指针会随之变化。</div><div class="line">拖移时按 Option 键	| 拷贝拖移的项目。拖移项目时指针会随之变化。</div><div class="line">拖移时按下 Option-Command	| 为拖移的项目制作替身。拖移项目时指针会随之变化。</div><div class="line">Option-点按伸缩三角形| 	打开所选文件夹内的所有文件夹。此快捷键仅在列表视图中有效。</div><div class="line">Command-点按窗口标题	| 查看包含当前文件夹的文件夹。</div></pre></td></tr></table></figure>
<h1 id="睡眠、注销和关机快捷键"><a href="#睡眠、注销和关机快捷键" class="headerlink" title="睡眠、注销和关机快捷键"></a>睡眠、注销和关机快捷键</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">快捷键                                    |         描述</div><div class="line">电源按钮                                  | 轻点可打开 Mac 或将 Mac 从睡眠状态唤醒。  当 Mac 处于唤醒状态时，按住此按钮 1.5 秒钟会显示一个对话框，询问您是要重新启动、睡眠还是关机。如果您不想等待 1.5 秒钟，请按下 Control–电源按钮或 Control–介质推出键 。按住此按钮 5 秒钟会强制 Mac 关机。</div><div class="line">Control–Command–电源按钮	                 | 强制 Mac 重新启动。</div><div class="line">Control–Shift–（电源按钮或介质推出键 ）	 | 将显示器置于睡眠状态。</div><div class="line">Control–Command–介质推出键 	         | 退出所有 app，然后重新启动 Mac。如果任何打开的文稿有未存储的更改，系统将询问您是否要存储这些更改。</div><div class="line">Control–Option–Command–（电源按钮或介质推出键 ） | 	退出所有 app，然后关闭 Mac。如果任何打开的文稿有未存储的更改，系统将询问您是否要存储这些更改。</div><div class="line">Shift-Command-Q	                         | 注销您的 macOS 用户帐户。系统将提示您确认。</div><div class="line">Option-Shift-Command-Q	                 | 立即注销您的 macOS 用户帐户，且系统不提示您确认。</div></pre></td></tr></table></figure>
<h1 id="Mac-的启动组合键"><a href="#Mac-的启动组合键" class="headerlink" title="Mac 的启动组合键"></a>Mac 的启动组合键</h1><p>在启动期间按住某些键可以使用一些 Mac 功能。 请在 Mac 开机并听到启动声后立即按住这些键。请一直按住，直至所述行为出现。以下组合适用于基于 Intel 的 Mac 电脑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">在启动期间按住	| 描述</div><div class="line">Shift ⇧	        | 以安全模式启动。</div><div class="line">Option ⌥        | 	启动进入启动管理器。</div><div class="line">C	        | 从可引导的 CD、DVD 或 USB 闪存驱动器（如 OS X 安装介质）启动。</div><div class="line">D	        | 启动进入 Apple Hardware Test 或 Apple Diagnostics，具体取决于您正在使用的 Mac。</div><div class="line">Option-D        | 	通过互联网启动进入 Apple Hardware Test 或 Apple Diagnostics。</div><div class="line">N	        | 从兼容的 NetBoot 服务器启动。</div><div class="line">Option-N        | 	使用默认的启动映像从 NetBoot 服务器启动。</div><div class="line">T	        | 以目标磁盘模式启动。</div><div class="line">X	        | 从 OS X 启动宗卷启动，否则 Mac 将从非 OS X 启动宗卷启动。</div><div class="line">Command (⌘)-R            | 	从 OS X 恢复功能启动。</div><div class="line">Command-Option-R         | 	通过互联网从 OS X 恢复功能启动。</div><div class="line">Command-Option-P-R	 | 重置 NVRAM。当再次听到启动声后，请松开这些键。</div><div class="line">Command-S            	 | 以单用户模式启动。</div><div class="line">Command-V                | 	以详细模式启动。</div><div class="line">推出键 (⏏)、F12、鼠标键或触控板按钮	 |    推出可移动介质，如光盘。</div></pre></td></tr></table></figure></p>
<p>整理了那么多快捷键，一时半时根本记不住，怎么办？除了有意识的经常使用、练习外，还有一款神奇软件 <strong><em><a href="https://www.mediaatelier.com/CheatSheet/" target="_blank" rel="external">CheatSheet</a></em></strong> 在任何应用程序下面长按Command ⌘ 键，即可以查看这款软件的快捷键操作。<br><img src="/2017/02/15/Mac键盘快捷键/../../../../images/m1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要使用键盘快捷键，请按住一个或多个修饰键，同时按快捷键的最后一个键。例如，要使用快捷键 Command-C（拷贝），请按住 Command 键并按 C 键，然后同时松开这两个键。Mac 菜单和键盘通常使用某些按键的符号，其中包括以下修饰键：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Command ⌘&lt;/li&gt;
&lt;li&gt;Shift ⇧&lt;/li&gt;
&lt;li&gt;Option ⌥&lt;/li&gt;
&lt;li&gt;Control ⌃&lt;/li&gt;
&lt;li&gt;Caps Lock ⇪&lt;/li&gt;
&lt;li&gt;Fn&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="工具" scheme="http://lzrlizhirong.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="mac" scheme="http://lzrlizhirong.github.io/tags/mac/"/>
    
      <category term="工具" scheme="http://lzrlizhirong.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>ES-5.0.2-学习(8)--分布式文档存储</title>
    <link href="http://lzrlizhirong.github.io/2017/02/14/ES-5-0-2-%E5%AD%A6%E4%B9%A0-8-%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E6%A1%A3%E5%AD%98%E5%82%A8-wait-for-active-shards%E6%96%B0%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/"/>
    <id>http://lzrlizhirong.github.io/2017/02/14/ES-5-0-2-学习-8-分布式文档存储-wait-for-active-shards新参数分析/</id>
    <published>2017-02-14T03:40:43.000Z</published>
    <updated>2017-02-14T06:38:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>学完ES分布式集群的工作原理以及一些基本的将数据放入索引然后检索它们的所有方法，我们可以继续学习在分布式系统中，每个分片的文档是被如何索引和查询的。<br><a id="more"></a></p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>首先，我们需要明白，文档和分片之间是如何匹配的，这就是路由。当你索引一个文档，它被存储在单独一个主分片上。Elasticsearch是如何知道文档属于哪个分片的呢？当你创建一个新文档，它是如何知道是应该存储在分片1还是分片2上的呢？</p>
<p>进程不能是随机的，因为我们将来要检索文档。事实上，它根据一个简单的算法决定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shard = hash(routing) % number_of_primary_shards</div></pre></td></tr></table></figure></p>
<p><em>routing</em>值是一个任意字符串，它默认是<em>_id</em>但也可以自定义。这个<em>routing</em>字符串通过哈希函数生成一个数字，然后除以主切片的数量得到一个余数(remainder)，余数的范围永远是<em>0</em>到<em>number_of_primary_shards - 1</em>，这个数字就是特定文档所在的分片。</p>
<p>这也解释了为什么主分片的数量只能在创建索引时定义且不能修改：如果主分片的数量在未来改变了，所有先前的路由值就失效了，文档也就永远找不到了。</p>
<p>所有的文档API（get、index、delete、bulk、update、mget）都接收一个routing参数，它用来自定义文档到分片的映射。自定义路由值可以确保所有相关文档——例如属于同一个人的文档——被保存在同一分片上。</p>
<p>例如，可以这样设置参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">POST twitter/tweet?routing=kimchy</div><div class="line">&#123;</div><div class="line">    &quot;user&quot; : &quot;kimchy&quot;,</div><div class="line">    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,</div><div class="line">    &quot;message&quot; : &quot;trying out Elasticsearch&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="主分片和复制分片如何交互"><a href="#主分片和复制分片如何交互" class="headerlink" title="主分片和复制分片如何交互"></a>主分片和复制分片如何交互</h1><p>在文档确认存储到哪个主分片以后，接下来就是主分片将数据复制到复制分片的任务，为了阐述意图，我们假设有三个节点的集群。它包含一个叫做<em>blogs</em>的索引并拥有两个主分片。每个主分片有两个复制分片。相同的分片不会放在同一个节点上，所以我们的集群是这样的：<br><img src="/2017/02/14/ES-5-0-2-学习-8-分布式文档存储-wait-for-active-shards新参数分析/../../../../images/e81.png" alt=""><br>我们能够发送请求给集群中任意一个节点。每个节点都有能力处理任意请求。每个节点都知道任意文档所在的节点，所以也可以将请求转发到需要的节点。下面的例子中，我们将发送所有请求给Node 1，这个节点我们将会称之为请求节点(requesting node)。一般情况下，当我们发送请求，最好的做法是循环通过所有节点请求，这样可以平衡负载。</p>
<h1 id="新建、索引和删除文档"><a href="#新建、索引和删除文档" class="headerlink" title="新建、索引和删除文档"></a>新建、索引和删除文档</h1><p>新建、索引和删除请求都是写(write)操作，它们必须在主分片上成功完成才能复制到相关的复制分片上。</p>
<p>下面是在主分片和复制分片上成功新建、索引或删除一个文档必要的顺序步骤：<br><img src="/2017/02/14/ES-5-0-2-学习-8-分布式文档存储-wait-for-active-shards新参数分析/../../../../images/e82.png" alt=""></p>
<ol>
<li>客户端给Node 1发送新建、索引或删除请求。</li>
<li>节点使用文档的_id确定文档属于分片0。它转发请求到Node 3，分片0位于这个节点上。</li>
<li>Node 3在主分片上执行请求，如果成功，它转发请求到相应的位于Node 1和Node 2的复制节点上。当所有的复制节点报告成功，Node 3报告成功到请求的节点，请求的节点再报告给客户端。客户端接收到成功响应的时候，文档的修改已经被应用于主分片和所有的复制分片。你的修改生效了。</li>
</ol>
<p>有很多可选的请求参数允许你更改这一过程。你可能想牺牲一些安全来提高性能。这些选项很少使用因为Elasticsearch已经足够快。</p>
<p><strong><em>注意：</em></strong>下面的参数只对ElasticSearch 5.0以下的版本有效，在ElasticSearch 5.0之后貌似使用wait_for_active_shards代替了consistency。所以之前的参数了解即可，实际可以参考：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.0/indices-create-index.html" target="_blank" rel="external">Create Index—Wait For Active Shards</a>。</p>
<h2 id="replication（注意在ElasticSearch-5-0开始被废弃）"><a href="#replication（注意在ElasticSearch-5-0开始被废弃）" class="headerlink" title="replication（注意在ElasticSearch 5.0开始被废弃）"></a>replication（注意在ElasticSearch 5.0开始被废弃）</h2><p>复制默认的值是<em>sync</em>。这将导致主分片得到复制分片的成功响应后才返回。</p>
<p>如果你设置<em>replication</em>为<em>async</em>，请求在主分片上被执行后就会返回给客户端。它依旧会转发请求给复制节点，但你将不知道复制节点成功与否。</p>
<p>上面的这个选项不建议使用。默认的<em>sync</em>复制允许Elasticsearch强制反馈传输。<em>async</em>复制可能会因为在不等待其它分片就绪的情况下发送过多的请求而使Elasticsearch过载。</p>
<h2 id="consistency（注意在ElasticSearch-5-0开始被废弃）"><a href="#consistency（注意在ElasticSearch-5-0开始被废弃）" class="headerlink" title="consistency（注意在ElasticSearch 5.0开始被废弃）"></a>consistency（注意在ElasticSearch 5.0开始被废弃）</h2><p>默认主分片在尝试写入时需要规定数量(<em>quorum</em>)或过半的分片（可以是主节点或复制节点）可用。这是防止数据被写入到错的网络分区。规定的数量计算公式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int( (primary + number_of_replicas) / 2 ) + 1</div></pre></td></tr></table></figure></p>
<p><em>consistency</em>允许的值为<em>one</em>（只有一个主分片），<em>all</em>（所有主分片和复制分片）或者默认的<em>quorum</em>或过半分片。</p>
<p>注意<em>number_of_replicas</em>是在索引中的的设置，用来定义复制分片的数量，而不是现在活动的复制节点的数量。如果你定义了索引有3个复制节点，那规定数量是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int( (primary + 3 replicas) / 2 ) + 1 = 3</div></pre></td></tr></table></figure></p>
<p>但如果你只有2个节点，那你的活动分片不够规定数量，也就不能索引或删除任何文档。</p>
<p><strong><em>注意：</em></strong></p>
<ul>
<li>新索引默认有1个复制分片，这意味着为了满足<em>quorum</em>的要求需要两个活动的分片。当然，这个默认设置将阻止我们在单一节点集群中进行操作。为了避开这个问题，规定数量只有在<em>number_of_replicas</em>大于一时才生效。</li>
<li><strong>一个疑惑，是不是<em>primary</em>值一直都只会是1？？？</strong></li>
</ul>
<h2 id="wait-for-active-shards（新参数）"><a href="#wait-for-active-shards（新参数）" class="headerlink" title="wait_for_active_shards（新参数）"></a>wait_for_active_shards（新参数）</h2><p>在ElasticSearch 5.0中可以用<em>wait_for_active_shards</em>参数表示：等待活动的分片，具体的值和<em>consistency</em>类似，下面用<em>wait_for_active_shards</em>演示一个实际使用的例子。</p>
<p>开始我们先设置一个新的索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PUT /active</div><div class="line">&#123;</div><div class="line">   &quot;settings&quot; : &#123;</div><div class="line">      &quot;number_of_shards&quot; : 3,</div><div class="line">      &quot;number_of_replicas&quot; : 3</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们默认先只打开两个节点，等下我们设置<em>wait_for_active_shards</em>值为3，按照上面讲解的我们如果只有两个节点，那么活动的分片最多也就2个，所以是不够的，会等待新的活动节点的到来。（这里我们只能通过少一个节点的方法演示缺少活动分片，因为我们不方便演示出让某个分片处于不活动的状态。）<br><img src="/2017/02/14/ES-5-0-2-学习-8-分布式文档存储-wait-for-active-shards新参数分析/../../../../images/e83.png" alt=""><br>因为我们只有两个节点，所以活动的分片最多也只有两个。下面我们执行文档存储操作，并且添加参数<em>wait_for_active_shards=3：</em><br><img src="/2017/02/14/ES-5-0-2-学习-8-分布式文档存储-wait-for-active-shards新参数分析/../../../../images/e84.png" alt=""><br>可以发现，确实开始处于等待状态，没有马上返回结果，下面我们参数开启第三个节点，让索引拥有第三个活动分片：<br><img src="/2017/02/14/ES-5-0-2-学习-8-分布式文档存储-wait-for-active-shards新参数分析/../../../../images/e85.png" alt=""><br><img src="/2017/02/14/ES-5-0-2-学习-8-分布式文档存储-wait-for-active-shards新参数分析/../../../../images/e86.png" alt=""><br>可以看到一旦我们的节点开启，文档的存储马上就会返回成功。</p>
<p>教程中关于这部分网上很多朋友不太理解，我们可以通过查看官方文档和实践去证明自己的想法，希望上面的分析大家可以理解一些，还有不对的地方大家可以一起学习。</p>
<h2 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h2><p>当分片副本不足时会怎样？Elasticsearch会等待更多的分片出现。默认等待一分钟。如果需要，你可以设置timeout参数让它终止的更早：100表示100毫秒，30s表示30秒。</p>
<h2 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h2><p>文档能够从主分片或任意一个复制分片被检索。<br><img src="/2017/02/14/ES-5-0-2-学习-8-分布式文档存储-wait-for-active-shards新参数分析/../../../../images/e87.png" alt=""><br>下面我们罗列在主分片或复制分片上检索一个文档必要的顺序步骤：</p>
<ol>
<li>客户端给Node 1发送get请求。</li>
<li>节点使用文档的_id确定文档属于分片0。分片0对应的复制分片在三个节点上都有。此时，它转发请求到Node 2。</li>
<li>Node 2返回文档(document)给Node 1然后返回给客户端。<br>对于读请求，为了平衡负载，请求节点会为每个请求选择不同的分片——它会循环所有分片副本（包括主分片）。</li>
</ol>
<p>可能的情况是，一个被索引的文档已经存在于主分片上却还没来得及同步到复制分片上。这时复制分片会报告文档未找到，主分片会成功返回文档。一旦索引请求成功返回给用户，文档则在主分片和复制分片都是可用的。</p>
<h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><p><em>update</em> API结合了之前提到的读和写的模式。<br><img src="/2017/02/14/ES-5-0-2-学习-8-分布式文档存储-wait-for-active-shards新参数分析/../../../../images/e88.png" alt=""><br>下面我们罗列执行局部更新必要的顺序步骤：</p>
<ol>
<li>客户端给<em>Node 1</em>发送更新请求。</li>
<li>它转发请求到主分片所在节点<em>Node 3</em>。</li>
<li><em>Node 3</em>从主分片检索出文档，修改<em>_source</em>字段的JSON，然后在主分片上重建索引。如果有其他进程修改了文档，它以<em>retry_on_conflict</em>设置的次数重复步骤3，都未成功则放弃。</li>
<li>如果<em>Node 3</em>成功更新文档，它同时转发文档的新版本到Node 1和Node 2上的复制节点以重建索引。当所有复制节点报告成功，Node 3返回成功给请求节点，然后返回给客户端。<br> <em>update</em> API还接受<em>routing</em>、<em>replication</em>（弃）、<em>consistency</em>（弃）和<em>timout</em>参数。</li>
</ol>
<h2 id="基于文档的复制"><a href="#基于文档的复制" class="headerlink" title="基于文档的复制"></a>基于文档的复制</h2><p>当主分片转发更改给复制分片时，并不是转发更新请求，而是转发整个文档的新版本。记住这些修改转发到复制节点是异步的，它们并不能保证到达的顺序与发送相同。如果Elasticsearch转发的仅仅是修改请求，修改的顺序可能是错误的，那得到的就是个损坏的文档。</p>
<h2 id="多文档模式"><a href="#多文档模式" class="headerlink" title="多文档模式"></a>多文档模式</h2><p><em>mget</em>和<em>bulk</em> API与单独的文档类似。差别是请求节点知道每个文档所在的分片。它把多文档请求拆成每个分片的对文档请求，然后转发每个参与的节点。</p>
<p>一旦接收到每个节点的应答，然后整理这些响应组合为一个单独的响应，最后返回给客户端。<br><img src="/2017/02/14/ES-5-0-2-学习-8-分布式文档存储-wait-for-active-shards新参数分析/../../../../images/e89.png" alt=""><br>下面我们将罗列通过一个<em>mget</em>请求检索多个文档的顺序步骤：</p>
<ol>
<li>客户端向Node 1发送<em>mget</em>请求。</li>
<li>Node 1为每个分片构建一个多条数据检索请求，然后转发到这些请求所需的主分片或复制分片上。当所有回复被接收，Node 1构建响应并返回给客户端。</li>
</ol>
<p>routing 参数可以被docs中的每个文档设置。<br><img src="/2017/02/14/ES-5-0-2-学习-8-分布式文档存储-wait-for-active-shards新参数分析/../../../../images/e810.png" alt=""><br>下面我们将罗列使用一个<em>bulk</em>执行多个<em>create</em>、<em>index</em>、<em>delete</em>和<em>update</em>请求的顺序步骤：</p>
<ol>
<li>客户端向Node 1发送<em>bulk</em>请求。</li>
<li>Node 1为每个分片构建批量请求，然后转发到这些请求所需的主分片上。</li>
<li>主分片一个接一个的按序执行操作。当一个操作执行完，主分片转发新文档（或者删除部分）给对应的复制节点，然后执行下一个操作。一旦所有复制节点报告所有操作已成功完成，节点就报告success给请求节点，后者(请求节点)整理响应并返回给客户端。</li>
</ol>
<p><em>bulk</em> API还可以在最上层使用<em>replication</em>（弃）和<em>consistency</em>（弃）参数，<em>routing</em>参数则在每个请求的元数据中使用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于在分布式系统中，每个分片的文档是被如何索引和查询的。虽然版本的更新有一些参数会更新，但是整体的内部实现应该不会有太大的变化，分享一个学习方法，学习的时候把新旧的版本内容通过对比，不仅可以更好理解知识，而且可以加深印象。更何况旧的不会被很快淘汰，学了又何妨！</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="240" src="//music.163.com/outchain/player?type=0&id=600358672&auto=0&height=430"></iframe>

<p>出处：<a href="http://www.cnblogs.com/wxw16/p/6192549.html" target="_blank" rel="external">http://www.cnblogs.com/wxw16/p/6192549.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学完ES分布式集群的工作原理以及一些基本的将数据放入索引然后检索它们的所有方法，我们可以继续学习在分布式系统中，每个分片的文档是被如何索引和查询的。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://lzrlizhirong.github.io/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://lzrlizhirong.github.io/tags/Elasticsearch/"/>
    
      <category term="分布式存储" scheme="http://lzrlizhirong.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>ES-5.0.2-学习(7)——分布式集群学习2</title>
    <link href="http://lzrlizhirong.github.io/2017/02/13/ES-5-0-2-%E5%AD%A6%E4%B9%A0-7-%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E5%AD%A6%E4%B9%A02/"/>
    <id>http://lzrlizhirong.github.io/2017/02/13/ES-5-0-2-学习-7-——分布式集群学习2/</id>
    <published>2017-02-13T05:58:08.000Z</published>
    <updated>2017-02-14T04:18:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=2919622&auto=0&height=66"></iframe><br>前面主要学习了ElasticSearch分布式集群的存储过程中集群、节点和分片的知识（<a href="http://lizhirong.club/2017/02/13/ES-5-0-2-%E5%AD%A6%E4%B9%A0-6-%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E5%AD%A6%E4%B9%A01/" target="_blank" rel="external">ES-5.0.2-学习(6)——分布式集群学习1</a>），下面主要分享应对故障的一些实践。<br><a id="more"></a></p>
<h1 id="应对故障"><a href="#应对故障" class="headerlink" title="应对故障"></a>应对故障</h1><p>前面说了很多关于复制分片可以应对节点失效，很好保证集群的安全性，下面我们可以尝试杀掉第一个节点的进程，我们的集群变化成如下（所有的操作都是ElasticSearch自动处理）：<br><img src="/2017/02/13/ES-5-0-2-学习-7-——分布式集群学习2/../../../../images/e71.png" alt=""><br>我们杀掉的节点是一个主节点。一个集群必须要有一个主节点才能使其功能正常，所以集群做的第一件事就是各节点选举了一个新的主节点：Node 2。</p>
<p>主分片1和2在我们杀掉Node 1时已经丢失，我们的索引在丢失主分片时不能正常工作。如果此时我们检查集群健康，我们将看到状态red：不是所有主分片都可用！</p>
<p>幸运的是丢失的两个主分片的完整拷贝存在于其他节点上，所以新主节点做的第一件事是把这些在Node 2和Node 3上的复制分片升级为主分片，这时集群健康回到yellow状态。这个提升是瞬间完成的，就好像按了一下开关。</p>
<p>为什么集群健康状态是yellow而不是green？我们有三个主分片，但是我们指定了每个主分片对应两个复制分片，当前却只有一个复制分片被分配，这就是集群状态无法达到green的原因，不过不用太担心这个：当我们杀掉Node 2，我们的程序依然可以在没有丢失数据的情况下继续运行，因为Node 3还有每个分片的拷贝。</p>
<p>如果我们重启Node 1，集群将能够重新分配丢失的复制分片，集群状况与上一节的图5：增加number_of_replicas到2 类似。如果Node 1依旧有旧分片的拷贝，它将会尝试再利用它们，它只会从主分片上复制在故障期间有数据变更的那一部分。</p>
<h1 id="故障实践1"><a href="#故障实践1" class="headerlink" title="故障实践1"></a>故障实践1</h1><p>上面是关于ElasticSearch在遇到故障时候的理论部分，下面我们开始实际操作。</p>
<h2 id="查看目前集群状态"><a href="#查看目前集群状态" class="headerlink" title="查看目前集群状态"></a>查看目前集群状态</h2><p>我们回顾一下之前的<em>blogs</em>索引，在结束最后的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PUT /blogs</div><div class="line">&#123;</div><div class="line">   &quot;settings&quot; : &#123;</div><div class="line">      &quot;number_of_shards&quot; : 3,    (主分片个数)</div><div class="line">      &quot;number_of_replicas&quot; : 2,    (每个主分片的复制分片个数)</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/02/13/ES-5-0-2-学习-7-——分布式集群学习2/../../../../images/e72.png" alt=""></p>
<h2 id="切断节点"><a href="#切断节点" class="headerlink" title="切断节点"></a>切断节点</h2><p>为了模拟这种情况，在我们自己的电脑上，直接用kill命令即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep elasticsearch   #获取到elasticsearch的进程id，例如5891</div><div class="line">kill 5891</div></pre></td></tr></table></figure></p>
<h2 id="查看集群的状态"><a href="#查看集群的状态" class="headerlink" title="查看集群的状态"></a>查看集群的状态</h2><p><img src="/2017/02/13/ES-5-0-2-学习-7-——分布式集群学习2/../../../../images/e73.png" alt=""><br>很正确，就是理论内容所描述中间会存在<em>red</em>的瞬间。<br>等·<br>等·<br>等·<br>可是等了半天，结果一直是<em>red</em>状态的结果，这是为什么呢？注意看提示无法连接到<em><a href="http://localhost:9200" target="_blank" rel="external">http://localhost:9200</a></em>，突然意识到，我们关闭的节点正好是<em>9200</em>端口的<em>Node 1</em>节点。所以我们需要修改<em>kibana.yml</em>配置文件的<em>elasticsearch.url</em>项：<br><img src="/2017/02/13/ES-5-0-2-学习-7-——分布式集群学习2/../../../../images/e74.png" alt=""></p>
<h2 id="再次查看集群的状态"><a href="#再次查看集群的状态" class="headerlink" title="再次查看集群的状态"></a>再次查看集群的状态</h2><p>终于，可以看到我们想要的结果，ElasticSearch集群正如上面所说的重新选Node 2作为新的主节点：<br><img src="/2017/02/13/ES-5-0-2-学习-7-——分布式集群学习2/../../../../images/e75.png" alt=""><br>我们还可以注意到集群的健康状况从绿色变成了黄色，这是因为我们设置每个主节点2个复制分片，而现在还有一个复制节点处于不可用状态。</p>
<h1 id="故障实践2"><a href="#故障实践2" class="headerlink" title="故障实践2"></a>故障实践2</h1><p>回顾之前的一个集群状态，<em>blogs</em>索引只设置一个复制分片的情况下：<br><img src="/2017/02/13/ES-5-0-2-学习-7-——分布式集群学习2/../../../../images/e76.png" alt=""><br>如果在这种情况下，我们把其中的任何一个节点关闭，会出现什么效果呢？我们分析看，至少我们关闭任何一个节点都能保所有的分片都还能存在。比如我们删除<em>Node 2</em>节点，正常情况下，<em>Node 2</em>中的分片0作为主分片被删除后，主节点会分配<em>Node 1</em>节点下复制分片0重新作为主分片0，而<em>Node 2</em>中的分片1本身是复制分片，直接删除即可，但是ElasticSearch集群，除此之外还会不会有其他操作。那就是，从新在两个节点中把所有的复制分片都置为可用。下面我们看结果：<br><img src="/2017/02/13/ES-5-0-2-学习-7-——分布式集群学习2/../../../../images/e77.png" alt=""><br>首先我们看到的和我们前面分析的一样，主节点会分配Node 1节点下复制分片0重新作为主分片0，但是也可以看到现在集群的健康状况是黄色，因为存在复制节点处于不可用状态。我们继续等。。。：<br><img src="/2017/02/13/ES-5-0-2-学习-7-——分布式集群学习2/../../../../images/e78.png" alt=""><br>终于我们可以看到，ElasticSearch集群确实会把所有的复制节点又都置为可用状态，因为节点存在它不拥有的分片，就可以创建这个节点，最大程度的保证高可用性。</p>
<h1 id="实践注意点"><a href="#实践注意点" class="headerlink" title="实践注意点"></a>实践注意点</h1><p>在测试过程中，ElasticSearch集群确实可以帮助我们重新分配分片的状态，但是需要注意的是，每次一个节点关闭的时候，集群需要一定的时间去管理，如果这时候我们很快的将两个节点关闭，ElasticSearch集群将无法挽救回没有主分片，也没有复制分片的那些数据，所以测试的时候需要知道这一点。</p>
<p>不过这也反映我们在学习分享1中描述的，如果我们的复制节点足够多的话，我们可以保证高可用的能力就却强大，因为允许节点故障的次数更多，而且我们的节点故障以后，运维又可以将节点重启，继续斗争！！！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>现在我们对分片如何使Elasticsearch可以水平扩展并保证数据安全有了一个清晰的认识。真正感受到Elasticsearch天生就是分布式的，确实很强大！</p>
<p>出处：<a href="http://www.cnblogs.com/wxw16/p/6188560.html" target="_blank" rel="external">http://www.cnblogs.com/wxw16/p/6188560.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=2919622&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;前面主要学习了ElasticSearch分布式集群的存储过程中集群、节点和分片的知识（&lt;a href=&quot;http://lizhirong.club/2017/02/13/ES-5-0-2-%E5%AD%A6%E4%B9%A0-6-%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E5%AD%A6%E4%B9%A01/&quot;&gt;ES-5.0.2-学习(6)——分布式集群学习1&lt;/a&gt;），下面主要分享应对故障的一些实践。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://lzrlizhirong.github.io/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://lzrlizhirong.github.io/tags/Elasticsearch/"/>
    
      <category term="分布式" scheme="http://lzrlizhirong.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ES-5.0.2-学习(6)——分布式集群学习1</title>
    <link href="http://lzrlizhirong.github.io/2017/02/13/ES-5-0-2-%E5%AD%A6%E4%B9%A0-6-%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E5%AD%A6%E4%B9%A01/"/>
    <id>http://lzrlizhirong.github.io/2017/02/13/ES-5-0-2-学习-6-——分布式集群学习1/</id>
    <published>2017-02-13T02:21:48.000Z</published>
    <updated>2017-02-14T06:39:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=31460216&auto=0&height=66"></iframe><br>在使用中我们把文档存入ElasticSearch，但是如果能够了解ElasticSearch内部是如何存储的，将会对我们学习ElasticSearch有很清晰的认识。本文中的所使用的ElasticSearch集群环境，可以通过查看 <em><a href="http://lizhirong.club/2017/02/10/ES-5-0-2-%E5%AD%A6%E4%B9%A0-3-%E2%80%94%E2%80%94%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9/" target="_blank" rel="external">ES-5.0.2-学习(3)——单台服务器部署多个节点</a></em> 搭建学习。<br><a id="more"></a><br>ElasticSearch用于构建高可用和可扩展的系统。扩展的方式可以是购买更好的服务器(纵向扩展(vertical scale or scaling up))或者购买更多的服务器（横向扩展(horizontal scale or scaling out)）。</p>
<p>Elasticsearch虽然能从更强大的硬件中获得更好的性能，但是纵向扩展有它的局限性。真正的扩展应该是横向的，它通过增加节点来均摊负载和增加可靠性。</p>
<p>对于大多数数据库而言，横向扩展意味着你的程序将做非常大的改动才能利用这些新添加的设备。对比来说，Elasticsearch天生就是分布式的：它知道如何管理节点来提供高扩展和高可用。这意味着你的程序不需要关心这些。</p>
<p>下面的例子主要围绕着集群(cluster)、节点(node)和分片(shard)讲解，相信学习以后，对于学习Elasticsearch会有很大收获。</p>
<h1 id="空集群"><a href="#空集群" class="headerlink" title="空集群"></a>空集群</h1><p>如果我们启动一个单独的节点，它还没有数据和索引，这个集群看起来如下图：<br><img src="/2017/02/13/ES-5-0-2-学习-6-——分布式集群学习1/../../../../images/e61.png" alt=""><br>只有一个空节点的集群。一个节点(node)就是一个Elasticsearch实例，而一个集群(cluster)由一个或多个节点组成，它们具有相同cluster.name，它们协同工作，分享数据和负载。当加入新的节点或者删除一个节点时，集群就会感知到并平衡数据。</p>
<p>集群中一个节点会被选举为主节点(master)，它将临时管理集群级别的一些变更，例如新建或删除索引、增加或移除节点等。主节点不参与文档级别的变更或搜索，这意味着在流量增长的时候，该主节点不会成为集群的瓶颈。任何节点都可以成为主节点。我们例子中的集群只有一个节点，所以它会充当主节点的角色。</p>
<p>作为用户，我们能够与集群中的任何节点通信，包括主节点。每一个节点都知道文档存在于哪个节点上，它们可以转发请求到相应的节点上。我们访问的节点负责收集各节点返回的数据，最后一起返回给客户端。这一切都由Elasticsearch处理。</p>
<h1 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h1><p>在Elasticsearch集群中可以监控统计很多信息，但是只有一个是最重要的：集群健康(cluster health)。<br>集群健康有三种状态：green、yellow或red，健康状况在后面会有很多体现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_cluster/health</div></pre></td></tr></table></figure></p>
<p>在一个没有索引的空集群中运行如上查询，将返回这些信息：</p>
<blockquote>
<p>{<br>   “cluster_name”:          “elasticsearch”,<br>   “status”:                “green”,<br>   “timed_out”:             false,<br>   “number_of_nodes”:       1,<br>   “number_of_data_nodes”:  1,<br>   “active_primary_shards”: 0,<br>   “active_shards”:         0,<br>   “relocating_shards”:     0,<br>   “initializing_shards”:   0,<br>   “unassigned_shards”:     0<br>}</p>
</blockquote>
<p><strong><em>status</em></strong>： 是我们最感兴趣的字段。status字段提供一个综合的指标来表示集群的的服务状况。三种颜色各自的含义：</p>
<ul>
<li>green：所有主要分片和复制分片都可用。</li>
<li>yellow：所有主要分片可用，但不是所有复制分片都可用。</li>
<li>red：不是所有的主要分片都可用。</li>
</ul>
<h1 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h1><p>为了将数据添加到Elasticsearch，我们需要索引(index)——一个存储关联数据的地方。实际上，索引只是一个用来指向一个或多个分片(shards)的“逻辑命名空间(logical namespace)”.</p>
<p>一个分片(shard)是一个最小级别“工作单元(worker unit)”,它只是保存了索引中所有数据的一部分。并且先初步知道分片就是一个Lucene实例，它本身就是一个完整的搜索引擎。我们的文档存储在分片中，并且在分片中被索引，但是我们的应用程序不会直接与它们通信，取而代之的是，直接与索引通信。</p>
<p>分片是Elasticsearch在集群中分发数据的关键。把分片想象成数据的容器。文档存储在分片中，然后分片分配到你集群中的节点上。当你的集群扩容或缩小，Elasticsearch将会自动在你的节点间迁移分片，以使集群保持平衡。</p>
<p>分片可以是主分片(primary shard)或者是复制分片(replica shard)。你索引中的每个文档属于一个单独的主分片，所以主分片的数量决定了索引最多能存储多少数据。当索引创建完成的时候，主分片的数量就固定了，但是复制分片的数量可以随时调整。</p>
<p>复制分片只是主分片的一个副本，它可以防止硬件故障导致的数据丢失，同时可以提供读请求，比如搜索或者从别的分片取回文档。</p>
<p>让我们在集群中唯一一个空节点上创建一个叫做blogs的索引。默认情况下，一个索引被分配5个主分片，但是为了演示的目的，我们只分配3个主分片和一个复制分片（每个主分片都有一个复制分片）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PUT /blogs</div><div class="line">&#123;</div><div class="line">   &quot;settings&quot; : &#123;</div><div class="line">      &quot;number_of_shards&quot; : 3,</div><div class="line">      &quot;number_of_replicas&quot; : 1</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/02/13/ES-5-0-2-学习-6-——分布式集群学习1/../../../../images/e62.png" alt=""><br>我们的集群现在看起来就像上图——三个主分片都被分配到Node 1。如果我们现在检查集群健康(cluster-health)，我们将见到以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   &quot;cluster_name&quot;:          &quot;elasticsearch&quot;,</div><div class="line">   &quot;status&quot;:                &quot;yellow&quot;, &lt;1&gt;</div><div class="line">   &quot;timed_out&quot;:             false,</div><div class="line">   &quot;number_of_nodes&quot;:       1,</div><div class="line">   &quot;number_of_data_nodes&quot;:  1,</div><div class="line">   &quot;active_primary_shards&quot;: 3,</div><div class="line">   &quot;active_shards&quot;:         3,</div><div class="line">   &quot;relocating_shards&quot;:     0,</div><div class="line">   &quot;initializing_shards&quot;:   0,</div><div class="line">   &quot;unassigned_shards&quot;:     3 &lt;2&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>集群的状态现在是 yellow</li>
<li>我们的三个复制分片还没有被分配到节点上</li>
</ul>
<p>下面我们可以看下，在Kibana监控工具中查看具体情况，如下图：<br><img src="/2017/02/13/ES-5-0-2-学习-6-——分布式集群学习1/../../../../images/e63.png" alt=""><br>集群的健康状态yellow表示所有的主分片(primary shards)启动并且正常运行了——集群已经可以正常处理任何请求——但是复制分片(replica shards)还没有全部可用。事实上所有的三个复制分片现在都是unassigned状态——它们还未被分配给节点。在同一个节点上保存相同的数据副本是没有必要的，如果这个节点故障了，那所有的数据副本也会丢失。</p>
<p>现在我们的集群已经功能完备，但是依旧存在因硬件故障而导致数据丢失的风险。</p>
<h1 id="添加故障转移"><a href="#添加故障转移" class="headerlink" title="添加故障转移"></a>添加故障转移</h1><p>在单一节点上运行意味着有单点故障的风险——没有数据备份。幸运的是，要防止单点故障，我们唯一需要做的就是启动另一个节点。</p>
<p>具体启动方式可以查看 <em><a href="http://lizhirong.club/2017/02/10/ES-5-0-2-%E5%AD%A6%E4%B9%A0-3-%E2%80%94%E2%80%94%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9/" target="_blank" rel="external">ES-5.0.2-学习(3)——单台服务器部署多个节点</a></em> 。</p>
<p>如果我们启动了第二个节点，这个集群看起来就像下图。双节点集群——所有的主分片和复制分片都已分配:<br><img src="/2017/02/13/ES-5-0-2-学习-6-——分布式集群学习1/../../../../images/e64.png" alt=""><br>第二个节点已经加入集群，三个复制分片(replica shards)也已经被分配了——分别对应三个主分片，这意味着在丢失任意一个节点的情况下依旧可以保证数据的完整性。</p>
<p>文档的索引将首先被存储在主分片中，然后并发复制到对应的复制节点上。这可以确保我们的数据在主节点和复制节点上都可以被检索。</p>
<p><strong><em>cluster-health</em></strong> 现在的状态是 <strong><em>green</em></strong>，这意味着所有的6个分片（三个主分片和三个复制分片）都已可用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   &quot;cluster_name&quot;:          &quot;elasticsearch&quot;,</div><div class="line">   &quot;status&quot;:                &quot;green&quot;,</div><div class="line">   &quot;timed_out&quot;:             false,</div><div class="line">   &quot;number_of_nodes&quot;:       2,</div><div class="line">   &quot;number_of_data_nodes&quot;:  2,</div><div class="line">   &quot;active_primary_shards&quot;: 3,</div><div class="line">   &quot;active_shards&quot;:         6,</div><div class="line">   &quot;relocating_shards&quot;:     0,</div><div class="line">   &quot;initializing_shards&quot;:   0,</div><div class="line">   &quot;unassigned_shards&quot;:     0</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>集群的状态是green，我们的集群不仅是功能完备的，而且是高可用的。<br>同样我们可以看下实际的操作结果：<br><img src="/2017/02/13/ES-5-0-2-学习-6-——分布式集群学习1/../../../../images/e65.png" alt=""></p>
<h1 id="横向扩展"><a href="#横向扩展" class="headerlink" title="横向扩展"></a>横向扩展</h1><p>随着应用需求的增长，我们该如何扩展？如果我们启动第三个节点，我们的集群会重新组织自己，包含3个节点的集群——分片已经被重新分配以平衡负载：<br><img src="/2017/02/13/ES-5-0-2-学习-6-——分布式集群学习1/../../../../images/e66.png" alt=""><br>Node 3包含了分别来自Node 1和Node 2的一个分片，这样每个节点就有两个分片，和之前相比少了一个，这意味着每个节点上的分片将获得更多的硬件资源（CPU、RAM、I/O）。</p>
<p>分片本身就是一个完整的搜索引擎，它可以使用单一节点的所有资源。我们拥有6个分片（3个主分片和三个复制分片），最多可以扩展到6个节点，每个节点上有一个分片，每个分片可以100%使用这个节点的资源。</p>
<p>同样我们可以看下实际的操作结果：<br><img src="/2017/02/13/ES-5-0-2-学习-6-——分布式集群学习1/../../../../images/e67.png" alt=""></p>
<h1 id="继续扩展"><a href="#继续扩展" class="headerlink" title="继续扩展"></a>继续扩展</h1><p>如果我们要扩展到6个以上的节点，要怎么做？</p>
<p>主分片的数量在创建索引时已经确定。实际上，这个数量定义了能存储到索引里数据的最大数量（实际的数量取决于你的数据、硬件和应用场景）。然而，主分片或者复制分片都可以处理读请求——搜索或文档检索，所以数据的冗余越多，我们能处理的搜索吞吐量就越大。</p>
<p>复制分片的数量可以在运行中的集群中动态地变更，这允许我们可以根据需求扩大或者缩小规模。让我们把复制分片的数量从原来的1增加到2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PUT /blogs/_settings</div><div class="line">&#123;</div><div class="line">   &quot;number_of_replicas&quot; : 2</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/02/13/ES-5-0-2-学习-6-——分布式集群学习1/../../../../images/e68.png" alt=""><br>从图中可以看出，blogs索引现在有9个分片：3个主分片和6个复制分片。这意味着我们能够扩展到9个节点，再次变成每个节点一个分片。这样使我们的搜索性能相比原始的三节点集群增加“三倍”。</p>
<p>实际操作也是同样的效果：<br><img src="/2017/02/13/ES-5-0-2-学习-6-——分布式集群学习1/../../../../images/e69.png" alt=""><br><strong><em>注意：</em></strong>可以看到上面的“三倍”我们用加了引号，因为在同样数量的节点上增加更多的复制分片并不一定提高性能，因为这样做的话平均每个分片的所占有的硬件资源就减少了（大部分请求都聚集到了分片少的节点，导致一个节点吞吐量太大，反而降低性能），你需要增加硬件来提高吞吐量。所以说添加复制分片和添加节点，在保证成本的情况下，需要有一个平衡点。</p>
<p>不过这些额外的复制节点还是有另外一个好处，使我们有更多的冗余：通过以上对节点的设置，我们能够承受两个节点故障而不丢失数据。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于ES分布式集群如果对节点、分片的处理基本学习完毕，可以感受到ES分布式集群的自动化，对于用户来说几乎完全透明化。但是，一个分布式集群主要看它的高性能、高并发和高可用。上面的内容虽然体现了一些，但是还包括对故障的处理能力，这部分将在 <a href="http://lizhirong.club/2017/02/13/ES-5-0-2-%E5%AD%A6%E4%B9%A0-7-%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E5%AD%A6%E4%B9%A02/" target="_blank" rel="external">ES-5.0.2-学习(7)——分布式集群学习2</a> 继续和大家分享。</p>
<p>出处：<a href="http://www.cnblogs.com/wxw16/p/6188044.html" target="_blank" rel="external">http://www.cnblogs.com/wxw16/p/6188044.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=31460216&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;在使用中我们把文档存入ElasticSearch，但是如果能够了解ElasticSearch内部是如何存储的，将会对我们学习ElasticSearch有很清晰的认识。本文中的所使用的ElasticSearch集群环境，可以通过查看 &lt;em&gt;&lt;a href=&quot;http://lizhirong.club/2017/02/10/ES-5-0-2-%E5%AD%A6%E4%B9%A0-3-%E2%80%94%E2%80%94%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9/&quot;&gt;ES-5.0.2-学习(3)——单台服务器部署多个节点&lt;/a&gt;&lt;/em&gt; 搭建学习。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://lzrlizhirong.github.io/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://lzrlizhirong.github.io/tags/Elasticsearch/"/>
    
      <category term="分布式" scheme="http://lzrlizhirong.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ES-5.0.2-学习(5)--第一个ES例子</title>
    <link href="http://lzrlizhirong.github.io/2017/02/10/ES-5-0-2-%E5%AD%A6%E4%B9%A0-3-%E7%AC%AC%E4%B8%80%E4%B8%AAES%E4%BE%8B%E5%AD%90/"/>
    <id>http://lzrlizhirong.github.io/2017/02/10/ES-5-0-2-学习-3-第一个ES例子/</id>
    <published>2017-02-10T09:35:28.000Z</published>
    <updated>2017-02-14T06:40:13.000Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=436514312&auto=0&height=66"></iframe><br>想要知道ElasticSearch是如何使用的，最快的方式就是通过一个简单的例子，第一个例子将会包括基本概念如索引、搜索、和聚合等，需求是关于公司管理员工的一些业务。<br><a id="more"></a><br># 员工文档索引<br>业务首先需要存储员工数据。这将采取一个员工文档的形式：单个文档表示单个员工。在Elasticsearch中存储数据的行为称为索引，但是在索引文档之前，我们需要决定在哪里存储它。<br>在Elasticsearch中，文档属于某个类型，这些类型位于索引中。可以绘制一些（粗略）与传统关系数据库的对比：<br><em> <strong>Relational DB  ⇒ Databases ⇒ Tables ⇒ Rows      ⇒ Columns</strong>
</em> <strong>Elasticsearch  ⇒ Indices   ⇒ Types  ⇒ Documents ⇒ Fields</strong><br><br>Elasticsearch集群可以包含多个索引（数据库），这些索引又包含多个类型（表）。这些类型包含多个文档（行），每个文档都有多个字段（列）。<br>你可能已经注意到，在Elasticsearch的上下文中，索引被重载了几个含义。如下：<br><em> <strong>索引（名词）：</strong>正如前面所解释的那样，索引就像传统的关系数据库中的数据库一样。它是存储相关文档的地方。index的复数形式是indices或indexes。
</em> <strong>索引（动词）：</strong>索引一个文档是将一个文档存储在索引（名词）中，以便它可以检索和查询。它很像插入关键词SQL。此外，如果文档已经存在，新的文档将取代旧的。<br><em> <strong>倒排索引：</strong>关系数据库中增加一个索引，如B-树索引，对特定列为了提高数据检索的速度。Elasticsearch和Lucene提供相同目的的索引称为倒排索引。<br>默认情况下，文档中的每个字段索引（有一个倒排索引）这样的搜索。一个没有倒排索引字段不可搜索<br><br>因此我们的员工目录，我们需要处理如下事情：
</em> 索引的每个文档，包含每个员工的所有细节。<br><em> 每个文档都属于**</em><code>employee</code><strong><em>类型。
</em> 类型都包含在*</strong><code>megacop</code><strong><em>索引中。
</em> 该索引将驻留我们Elasticsearch集群内。<br><br>下面通过命令去索引第一个员工：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">PUT /megacorp/employee/1</div><div class="line">&#123;</div><div class="line">    &quot;first_name&quot; : &quot;John&quot;,</div><div class="line">    &quot;last_name&quot; :  &quot;Smith&quot;,</div><div class="line">    &quot;age&quot; :        25,</div><div class="line">    &quot;about&quot; :      &quot;I love to go rock climbing&quot;,</div><div class="line">    &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>注意 *</strong><code>/megacorp/employee/1</code><strong><em> 包含的信息:<br>&gt; </em></strong><code>megacorp：</code><strong><em>索引的名称
</em></strong><code>emplogee：</code><strong><em>类型的名称
</em></strong><code>1：</code><strong>*员工的id<br><br>成功执行返回的是一个JSON文本，包含所有关于该员工的信息。

</strong>注意：<strong><br>1. 如果执行过程中失败了，可能存在的原因是elasticsearch默认配置中不允许自动创建索引，所以我们可以先简单在elasticsearch.yml配置文件添加action.auto_create_index：true，允许自动创建索引。<br>2. 没有必要首先执行任何管理任务，如创建一个索引或指定每个字段所包含的数据类型。我们可以直接索引一个文档。Elasticsearch附带默认的一切，因此所有必要的管理任务都会使用默认值在后台处理。<br><br>在目录中添加更多的员工：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">PUT /megacorp/employee/2</div><div class="line">&#123;</div><div class="line">    &quot;first_name&quot; :  &quot;Jane&quot;,</div><div class="line">    &quot;last_name&quot; :   &quot;Smith&quot;,</div><div class="line">    &quot;age&quot; :         32,</div><div class="line">    &quot;about&quot; :       &quot;I like to collect rock albums&quot;,</div><div class="line">    &quot;interests&quot;:  [ &quot;music&quot; ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">PUT /megacorp/employee/3</div><div class="line">&#123;</div><div class="line">    &quot;first_name&quot; :  &quot;Douglas&quot;,</div><div class="line">    &quot;last_name&quot; :   &quot;Fir&quot;,</div><div class="line">    &quot;age&quot; :         35,</div><div class="line">    &quot;about&quot;:        &quot;I like to build cabinets&quot;,</div><div class="line">    &quot;interests&quot;:  [ &quot;forestry&quot; ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br># 检索文档<br>现在我们有一些数据存储在Elasticsearch中，我们可以开始处理这个应用程序的业务需求。第一个要求是检索单个员工数据的能力。<br>这在Elasticsearch中很容易。我们只需执行HTTP GET请求并指定文档的地址——索引，类型和ID。使用这三个信息，我们可以返回原始的JSON文档，并且响应包含有关文档的一些元数据，以及Douglas Fir的原始JSON文档作为_source字段：<br><img src="/2017/02/10/ES-5-0-2-学习-3-第一个ES例子/../../../../images/e51.png" alt=""><br>可以查看：<a href="http://lizhirong.club/2017/02/10/ES-5-0-2-%E5%AD%A6%E4%B9%A0-4-%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2/" target="_blank" rel="external">ES-5.0.2-学习(4)–简单搜索</a><br><br>以同样的方式，我们将HTTP动词从PUT更改为GET以便检索文档，我们可以使用DELETE动词删除文档，并使用HEAD动词检查文档是否存在。要用更新的版本替换现有文档，我们只需再次PUT。<br>GET很简单，可以得到要求的文件。尝试一些更高级的东西，我们可以搜索所有员工，请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /megacorp/employee/_search</div></pre></td></tr></table></figure><br><br>你可以看到我们仍在使用索引megacorp和类型employee，但是我们现在使用_search端点，而不是指定文档ID。响应包括我们在hits数组中的所有三个文档。默认情况下，搜索将返回前10个结果。<br>响应不仅告诉我们哪些文档匹配，而且还包括整个文档本身，以便向用户显示搜索结果的所有信息。<br>接下来，让我们尝试搜索在其姓氏中有“Smith”的员工。为此，我们将使用一个轻松的搜索方法，它很容易从命令行使用。此方法通常称为查询字符串搜索，因为我们将搜索作为URL查询字符串参数传递：<br><img src="/2017/02/10/ES-5-0-2-学习-3-第一个ES例子/../../../../images/e52.png" alt=""><br><br># DSL查询<br>查询字符串搜索对于从命令行进行搜索非常方便，但它有其局限性。Elasticsearch提供了一种丰富，灵活的查询语言，称为查询DSL，它允许我们构建更复杂，更健壮的查询。<br>使用JSON请求正文指定域特定语言（DSL）。我们可以代表所有以前的搜索，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /megacorp/employee/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match&quot; : &#123;</div><div class="line">            &quot;last_name&quot; : &quot;Smith&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>这将返回与上一个查询相同的结果。可以看到一些事情已经改变。例如，我们不再使用查询字符串参数，而是使用请求正文。此请求体是使用JSON构建的，并使用匹配查询。<br>让我们让搜索更复杂一点。我们仍然希望找到所有名字为Smith的员工，但我们只想要30岁以上的员工。我们的查询将稍微改变一点，以容纳一个过滤器，这使我们能够有效地执行结构化搜索：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">GET /megacorp/employee/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;bool&quot; : &#123;</div><div class="line">            &quot;must&quot; : &#123;</div><div class="line">                &quot;match&quot; : &#123;</div><div class="line">                    &quot;last_name&quot; : &quot;smith&quot; </div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            &quot;filter&quot; : &#123;</div><div class="line">                &quot;range&quot; : &#123;</div><div class="line">                    &quot;age&quot; : &#123; &quot;gt&quot; : 30 &#125; </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>我们添加了一个过滤器，执行范围搜索，并重复使用与以前相同的匹配查询。<br>现在我们的结果显示只有一个员工刚好是32并被命名为smith：<br><img src="/2017/02/10/ES-5-0-2-学习-3-第一个ES例子/../../../../images/e53.png" alt=""><br><br>*</strong>注意：<em>**关于过滤器在Elasticsearch2.0开始有很大的更新，所以有些过滤操作可能会报错。例如：<code>filtered query</code>已经被废弃。<br><br># 全文搜索（Full-Text Search）<br>到目前为止的搜索很简单：单个名字，按年龄过滤。让我们尝试更高级的全文搜索，传统数据库真正难以胜任的任务。<br>我们将寻找所有喜欢攀岩的员工：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /megacorp/employee/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match&quot; : &#123;</div><div class="line">            &quot;about&quot; : &quot;rock climbing&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>您可以看到我们使用与之前相同的匹配查询来搜索关于“攀岩”字段。我们得到两个匹配的文档：<br><img src="/2017/02/10/ES-5-0-2-学习-3-第一个ES例子/../../../../images/e54.png" alt=""><br>默认情况下，Elasticsearch按匹配结果的相关性分值（即每个文档与查询匹配程度）对匹配结果进行排序。第一个和最高分的结果是显而易见的：John·Smith关于字段清楚地说“攀岩”。<br>但为什么Jane·Smith也返回了？她的文档被返回的原因是因为在她的字段中提到了“rock”这个词。因为只有“岩石”被提及，而不是“攀登”，她的分数低于John的。<br>这是Elasticsearch如何在全文字段中进行搜索并返回最相关的结果的一个很好的例子。这种相关性的概念对于Elasticsearch很重要，并且是一个完全与传统关系数据库无关的概念，其中记录匹配或不匹配。<br># 精确字段搜索<br>在字段中查找单个字词是很好的，但有时你想要匹配字词或短语的确切序列。例如，我们可以执行一个查询，该查询将仅匹配包含“rock”和“climbing”的员工记录，并在短语“rock climbing”中显示彼此相邻的单词。<br>为此，我们使用改为match_phrase查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /megacorp/employee/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match_phrase&quot; : &#123;</div><div class="line">            &quot;about&quot; : &quot;rock climbing&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>仅返回John Smith的文档<br><img src="/2017/02/10/ES-5-0-2-学习-3-第一个ES例子/../../../../images/e55.png" alt=""><br># 高亮搜索结果<br>许多应用程序喜欢从每个搜索结果突出显示文本片段，以便用户可以看到文档与查询匹配的原因。在Elasticsearch中检索突出显示的片段很容易。<br>让我们重新运行我们以前的查询，但添加一个新的highlight参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GET /megacorp/employee/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match_phrase&quot; : &#123;</div><div class="line">            &quot;about&quot; : &quot;rock climbing&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;highlight&quot;: &#123;</div><div class="line">        &quot;fields&quot; : &#123;</div><div class="line">            &quot;about&quot; : &#123;&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>当我们运行此查询时，将返回与之前相同的返回，但现在我们在响应中得到一个新的部分，称为突出显示。<br>这包含来自about字段的文字片段，其中包含在 HTML标记中包含的匹配单词：<br><img src="/2017/02/10/ES-5-0-2-学习-3-第一个ES例子/../../../../images/e56.png" alt=""><br># 分析<br>最后，我们来到我们的最后一个业务需求：允许管理员在员工目录上运行分析。Elasticsearch具有称为聚合的功能，允许您对数据生成复杂的分析。它类似于GROUP BY中的SQL，但功能更强大。<br>例如，让我们找到我们的员工最喜欢的兴趣：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /megacorp/employee/_search</div><div class="line">&#123;</div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;all_interests&quot;: &#123;</div><div class="line">      &quot;terms&quot;: &#123; &quot;field&quot;: &quot;interests&quot; &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>如果Elasticsearch 5版本以前，将会返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   ...</div><div class="line">   &quot;hits&quot;: &#123; ... &#125;,</div><div class="line">   &quot;aggregations&quot;: &#123;</div><div class="line">      &quot;all_interests&quot;: &#123;</div><div class="line">         &quot;buckets&quot;: [</div><div class="line">            &#123;</div><div class="line">               &quot;key&quot;:       &quot;music&quot;,</div><div class="line">               &quot;doc_count&quot;: 2</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">               &quot;key&quot;:       &quot;forestry&quot;,</div><div class="line">               &quot;doc_count&quot;: 1</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">               &quot;key&quot;:       &quot;sports&quot;,</div><div class="line">               &quot;doc_count&quot;: 1</div><div class="line">            &#125;</div><div class="line">         ]</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>我们可以看到，两个员工对音乐感兴趣，一个在林业，一个在体育。这些聚合不是预先计算的，它们是从与当前查询匹配的文档即时生成的。<br>然而如果我们使用的是Elasticsearch 5版本以上的话，将会出现如下异常：<br><img src="/2017/02/10/ES-5-0-2-学习-3-第一个ES例子/../../../../images/e57.png" alt=""><br>我们可以查看 </em><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.0/fielddata.html#_fielddata_is_disabled_on_literal_text_literal_fields_by_default" target="_blank" rel="external">Elasticsearch 5.0文档——Fielddata is disabled on text fields by default</a>*<br>大概的意思是：Fielddata可以消耗大量的堆空间，特别是在加载高基数文本字段时。一旦fielddata已经加载到堆中，它在该段的生存期内保持。此外，加载fielddata是一个昂贵的过程，可以导致用户体验延迟命中。<br>所以fielddata默认禁用。如果尝试对文本字段上的脚本进行排序，聚合或访问值，就会看到这个异常，具体使用可以参考手册。<br># 总结<br>这个小例子是一个很好的演示了什么是Elasticsearch。它只是很肤浅的介绍了简单的使用，许多功能被省略，以保持简短。但是这也突出了开始构建高级搜索功能是多么容易。<br><br><br><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="240" src="//music.163.com/outchain/player?type=0&id=600358672&auto=0&height=430"></iframe>



<p>出处：<a href="http://www.cnblogs.com/wxw16/p/6185378.html" target="_blank" rel="external">http://www.cnblogs.com/wxw16/p/6185378.html</a><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=436514312&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;想要知道ElasticSearch是如何使用的，最快的方式就是通过一个简单的例子，第一个例子将会包括基本概念如索引、搜索、和聚合等，需求是关于公司管理员工的一些业务。&lt;br&gt;
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://lzrlizhirong.github.io/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://lzrlizhirong.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>ES-5.0.2-学习(4)--简单搜索</title>
    <link href="http://lzrlizhirong.github.io/2017/02/10/ES-5-0-2-%E5%AD%A6%E4%B9%A0-3-%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2/"/>
    <id>http://lzrlizhirong.github.io/2017/02/10/ES-5-0-2-学习-3-简单搜索/</id>
    <published>2017-02-10T08:28:55.000Z</published>
    <updated>2017-02-14T06:40:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="空搜索"><a href="#空搜索" class="headerlink" title="空搜索"></a>空搜索</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search</div></pre></td></tr></table></figure>
<p><img src="/2017/02/10/ES-5-0-2-学习-3-简单搜索/../../../../images/e41.png" alt=""><br><a id="more"></a><br>注：<strong>以下操作均是在kibana中，如图所示</strong><br><strong>hits：</strong></p>
<blockquote>
<ol>
<li>total 总数</li>
<li>hits 前10条数据</li>
<li>hits 数组中的每个结果都包含_index、_type和文档的_id字段，被加入到_source字段中这意味着在搜索结果中我们将可以直接使用全部文档。</li>
<li>每个节点都有一个_score字段，这是相关性得分(relevance score)，它衡量了文档与查询的匹配程度。默认的，返回的结果中关联性最大的文档排在首位；这意味着，它是按照_score降序排列的。没有指定任何查询，所以所有文档的相关性是一样的，因此所有结果的_score都是取得一个中间值1。  </li>
</ol>
</blockquote>
<p><strong>took：</strong>整个搜索请求花费的毫秒数。<br><strong>_shards：</strong>节点告诉我们参与查询的分片数（total字段），有多少是成功的（successful），有多少的是失败的（failed）。<br><strong>time_out：</strong>告诉我们查询超时与否。一般的，搜索请求不会超时。如果响应速度比完整的结果更重要，你可以定义timeout参数为10或者10ms（10毫秒），或者1s（1秒）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?timeout=10ms</div></pre></td></tr></table></figure></p>
<p>Elasticsearch将返回在请求超时前收集到的结果。<br><strong>注意：</strong> <strong><em>timeout不会停止执行查询，它仅仅告诉你目前顺利返回结果的节点然后关闭连接。在后台，其他分片可能依旧执行查询，尽管结果已经被发送。<br>使用超时是因为对于你的业务需求来说非常重要，而不是因为你想中断执行长时间运行的查询。</em></strong></p>
<h1 id="多索引和多类别"><a href="#多索引和多类别" class="headerlink" title="多索引和多类别"></a>多索引和多类别</h1><p>在所有索引的所有类型中搜索：<em>/_search</em><br>在索引gb的所有类型中搜索：<em>/gb/_search</em><br>在索引gb和us的所有类型中搜索：<em>/gb,us/_search</em><br>在以g或u开头的索引的所有类型中搜索：/g*,u*/_search<br>在索引gb的类型user中搜索：<em>/gb/user/_search</em><br>在索引gb和us的类型为user和tweet中搜索：<em>/gb,us/user,tweet/_search</em><br>在所有索引的user和tweet中搜索：<em>/_all/user,tweet/_search</em><br>当你搜索包含单一索引时，Elasticsearch转发搜索请求到这个索引的主分片或每个分片的复制分片上，然后聚集每个分片的结果。搜索包含多个索引也是同样的方式——只不过会有更多的分片被关联。</p>
<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>如果你想每页显示5个结果，页码从1到3，那请求如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GET /_search?size=5</div><div class="line">GET /_search?size=5&amp;from=5</div><div class="line">GET /_search?size=5&amp;from=10</div></pre></td></tr></table></figure></p>
<p>应该当心分页太深或者一次请求太多的结果。结果在返回前会被排序。但是记住一个搜索请求常常涉及多个分片。每个分片生成自己排好序的结果，它们接着需要集中起来排序以确保整体排序正确。<br>现在假设我们请求第1000页——结果10001到10010。工作方式都相同，不同的是每个分片都必须产生顶端的10010个结果。然后请求节点排序这50050个结果并丢弃50040个！</p>
<h1 id="简易搜索"><a href="#简易搜索" class="headerlink" title="简易搜索"></a>简易搜索</h1><p>search API有两种表单：一种是“简易版”的查询字符串(query string)将所有参数通过查询字符串定义，另一种版本使用JSON完整的表示请求体(request body)，这种富搜索语言叫做结构化查询语句（DSL）。<br>查询字符串搜索对于在命令行下运行特定情况下查询特别有用。例如这个语句查询所有类型为tweet并在tweet字段中包含elasticsearch字符的文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_all/tweet/_search?q=tweet:elasticsearch</div></pre></td></tr></table></figure></p>
<p>下一个语句查找name字段中包含”john”和tweet字段包含”mary”的结果。实际的查询只需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+name:john +tweet:mary</div></pre></td></tr></table></figure></p>
<p>但是url编码需要将查询字符串参数变得更加神秘：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?q=%2Bname%3Ajohn+%2Btweet%3Amary</div></pre></td></tr></table></figure></p>
<p>“+”前缀表示语句匹配条件必须被满足。类似的”-“前缀表示条件必须不被满足。所有条件如果没有+或-表示是可选的——匹配越多，相关的文档就越多。</p>
<h1 id="all字段"><a href="#all字段" class="headerlink" title="_all字段"></a>_all字段</h1><p>返回包含”mary”字符的所有文档的简单搜索：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search?q=mary</div></pre></td></tr></table></figure></p>
<p>当你索引一个文档，Elasticsearch把所有字符串字段值连接起来放在一个大字符串中，它被索引为一个特殊的字段_all。例如，当索引这个文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;tweet&quot;:    &quot;However did I manage before Elasticsearch?&quot;,</div><div class="line">    &quot;date&quot;:     &quot;2014-09-14&quot;,</div><div class="line">    &quot;name&quot;:     &quot;Mary Jones&quot;,</div><div class="line">    &quot;user_id&quot;:  1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这好比我们增加了一个叫做_all的额外字段值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;However did I manage before Elasticsearch? 2014-09-14 Mary Jones 1&quot;</div></pre></td></tr></table></figure></p>
<p>若没有指定字段，查询字符串搜索（即q=xxx）使用_all字段搜索。</p>
<h1 id="更复杂的语句"><a href="#更复杂的语句" class="headerlink" title="更复杂的语句"></a>更复杂的语句</h1><p>下一个搜索的语句：<br>_all field</p>
<ul>
<li>name字段包含”mary”或”john”</li>
<li>date晚于2014-09-10</li>
<li>_all字段包含”aggregations”或”geo”</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+name:(mary john) +date:&gt;2014-09-10 +(aggregations geo)</div></pre></td></tr></table></figure>
<p>编码后的查询字符串变得不太容易阅读<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?q=%2Bname%3A(mary+john)+%2Bdate%3A%3E2014-09-10+%2B(aggregations+geo)</div></pre></td></tr></table></figure></p>
<p>就像你上面看到的例子，简单查询字符串搜索惊人的强大。允许我们简洁明快的表示复杂的查询。这对于命令行下一次性查询或者开发模式下非常有用。<br>然而，你可以看到简洁带来了隐晦和调试困难。而且它很脆弱——查询字符串中一个细小的语法错误，像-、:、/或”错位就会导致返回错误而不是结果。<br>最后，查询字符串搜索允许任意用户在索引中任何一个字段上运行潜在的慢查询语句，可能暴露私有信息甚至使你的集群瘫痪。<br>取而代之的，生产环境我们一般依赖全功能的请求体搜索API，它能完成前面所有的事情，甚至更多。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="240" src="//music.163.com/outchain/player?type=0&id=600358672&auto=0&height=430"></iframe>


<p>出处：<a href="http://www.cnblogs.com/wxw16/p/6171016.html" target="_blank" rel="external">http://www.cnblogs.com/wxw16/p/6171016.html</a><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;空搜索&quot;&gt;&lt;a href=&quot;#空搜索&quot; class=&quot;headerlink&quot; title=&quot;空搜索&quot;&gt;&lt;/a&gt;空搜索&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;GET /_search&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;/2017/02/10/ES-5-0-2-学习-3-简单搜索/../../../../images/e41.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://lzrlizhirong.github.io/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://lzrlizhirong.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>ES-5.0.2-学习(3)——单台服务器部署多个节点</title>
    <link href="http://lzrlizhirong.github.io/2017/02/10/ES-5-0-2-%E5%AD%A6%E4%B9%A0-3-%E2%80%94%E2%80%94%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://lzrlizhirong.github.io/2017/02/10/ES-5-0-2-学习-3-——台服务器部署多个节点/</id>
    <published>2017-02-10T07:49:18.000Z</published>
    <updated>2017-02-14T06:40:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下单台服务器只会部署一个ElasticSearch node，但是在学习过程中，很多情况下会需要实现ElasticSearch的分布式效果，所以需要启动多个节点，但是学习开发环境（不想开多个虚拟机实现多个服务器的效果），所以就想着在一台服务器上部署多个结点（下文以2个结点作为例子），两个节点分别称为实例一、二。<br><a id="more"></a></p>
<h1 id="1、首先将elasticsearch-5-0-2文件夹再复制一份"><a href="#1、首先将elasticsearch-5-0-2文件夹再复制一份" class="headerlink" title="1、首先将elasticsearch-5.0.2文件夹再复制一份"></a>1、首先将elasticsearch-5.0.2文件夹再复制一份</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp -R elasticsearch-5.0.2 elasticsearch-5.0.2-node-2</div></pre></td></tr></table></figure>
<h1 id="2、主要工作就是修改elasticsearch-yml配置文件。"><a href="#2、主要工作就是修改elasticsearch-yml配置文件。" class="headerlink" title="2、主要工作就是修改elasticsearch.yml配置文件。"></a>2、主要工作就是修改elasticsearch.yml配置文件。</h1><p>实例二：config目录下的elasticsearch.yml内容<br>将node.name: node-1 修改为 node-2</p>
<h1 id="3、分别开启两个节点"><a href="#3、分别开启两个节点" class="headerlink" title="3、分别开启两个节点"></a>3、分别开启两个节点</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/elasticsearch</div></pre></td></tr></table></figure>
<h1 id="4、查询是否成功"><a href="#4、查询是否成功" class="headerlink" title="4、查询是否成功"></a>4、查询是否成功</h1><p>浏览器访问 <em><a href="http://localhost:9200/_cluster/health?pretty" target="_blank" rel="external">http://localhost:9200/_cluster/health?pretty</a></em><br>若出现类似如下则表示成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"></div><div class="line">    &quot;cluster_name&quot;: &quot;es-lzr&quot;,</div><div class="line">    &quot;status&quot;: &quot;green&quot;,</div><div class="line">    &quot;timed_out&quot;: false,</div><div class="line">    &quot;number_of_nodes&quot;: 2,</div><div class="line">    &quot;number_of_data_nodes&quot;: 2,</div><div class="line">    &quot;active_primary_shards&quot;: 17,</div><div class="line">    &quot;active_shards&quot;: 34,</div><div class="line">    &quot;relocating_shards&quot;: 0,</div><div class="line">    &quot;initializing_shards&quot;: 0,</div><div class="line">    &quot;unassigned_shards&quot;: 0,</div><div class="line">    &quot;delayed_unassigned_shards&quot;: 0,</div><div class="line">    &quot;number_of_pending_tasks&quot;: 0,</div><div class="line">    &quot;number_of_in_flight_fetch&quot;: 0,</div><div class="line">    &quot;task_max_waiting_in_queue_millis&quot;: 0,</div><div class="line">    &quot;active_shards_percent_as_number&quot;: 100.0</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也可以通过Kibana查看节点效果 <em><a href="http://localhost:5601" target="_blank" rel="external">http://localhost:5601</a></em> 账号 <em>elastic</em> 密码 <em>changeme</em><br><img src="/2017/02/10/ES-5-0-2-学习-3-——台服务器部署多个节点/../../../../images/e31.png" alt=""></p>
<h1 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h1><p>1.如果修改了配置文件的 <em>http.port、transport.tcp.port</em>项，一定要将各个节点的值设置不同，否则会出现占用的情况。正常如果不修改，默认会分配值。<br>2.示例二开启时，实例一报警告（实际操作中可以忽略）：</p>
<blockquote>
<p>[2016-12-11T18:06:43,678][WARN ][o.e.d.z.ElectMasterService] [node-1] value for setting “discovery.zen.minimum_master_nodes” is too low. This can result in data loss! Please set it to at least a quorum of master-eligible nodes (current value: [-1], total number of master-eligible nodes used for publishing in this round: [2])<br>是因为默认情况下 <em>discovery.zen.minimum_master_nodes=1</em> 一台服务器只能有一个主节点，所以在实例二的配置文件中可以添加 <em>node.master: false</em> 。</p>
</blockquote>
<p>3.示例二不能开启，报如下错误：</p>
<blockquote>
<p>[2016-12-11T16:53:02,711][INFO ][o.e.d.z.ZenDiscovery     ] [node-2] failed to send join request to master [{node-1}{vP19PMOyT2ilJKRAqgn78w}{jDULCExERXGHp4VXpbyuJA}{127.0.0.1}{127.0.0.1:9300}], reason [RemoteTransportException[[node-1][127.0.0.1:9300][internal:discovery/zen/join]]; nested: IllegalArgumentException[can’t add node {node-2}{vP19PMOyT2ilJKRAqgn78w}{qhDDVzwZQ0GXZXhIMmpGKA}{127.0.0.1}{127.0.0.1:9301}, found existing node {node-1}{vP19PMOyT2ilJKRAqgn78w}{jDULCExERXGHp4VXpbyuJA}{127.0.0.1}{127.0.0.1:9300} with the same id but is a different node instance]; ]<br>[2016-12-11T16:53:02,911][INFO ][o.e.x.m.e.Exporters      ] [node-2] skipping exporter [default_local] as it isn’t ready yet<br>[2016-12-11T16:53:02,912][ERROR][o.e.x.m.AgentService     ] [node-2] exception when exporting documents<br>org.elasticsearch.xpack.monitoring.exporter.ExportException: exporters are either not ready or faulty<br>    at org.elasticsearch.xpack.monitoring.exporter.Exporters.export(Exporters.java:188) ~[x-pack-5.0.2.jar:5.0.2]<br>    at org.elasticsearch.xpack.monitoring.AgentService$ExportingWorker.run(AgentService.java:208) [x-pack-5.0.2.jar:5.0.2]<br>    at java.lang.Thread.run(Thread.java:745) [?:1.8.0_111]</p>
</blockquote>
<p>是因为复制的elasticsearch文件夹下包含了data文件中示例一的节点数据，需要把示例二data文件下的文件清空。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="240" src="//music.163.com/outchain/player?type=0&id=600358672&auto=0&height=430"></iframe>



<p>出处：<a href="http://www.cnblogs.com/wxw16/p/6160186.html" target="_blank" rel="external">http://www.cnblogs.com/wxw16/p/6160186.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般情况下单台服务器只会部署一个ElasticSearch node，但是在学习过程中，很多情况下会需要实现ElasticSearch的分布式效果，所以需要启动多个节点，但是学习开发环境（不想开多个虚拟机实现多个服务器的效果），所以就想着在一台服务器上部署多个结点（下文以2个结点作为例子），两个节点分别称为实例一、二。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://lzrlizhirong.github.io/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://lzrlizhirong.github.io/tags/Elasticsearch/"/>
    
      <category term="kibana" scheme="http://lzrlizhirong.github.io/tags/kibana/"/>
    
  </entry>
  
  <entry>
    <title>为了保持逼格，不要停止写作</title>
    <link href="http://lzrlizhirong.github.io/2017/02/10/%E4%B8%BA%E4%BA%86%E4%BF%9D%E6%8C%81%E9%80%BC%E6%A0%BC%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%81%9C%E6%AD%A2%E5%86%99%E4%BD%9C/"/>
    <id>http://lzrlizhirong.github.io/2017/02/10/为了保持逼格，不要停止写作/</id>
    <published>2017-02-10T02:52:09.000Z</published>
    <updated>2017-02-14T06:40:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>“逼格”一词，网络上常见的解释是“装逼的格调”，听起来有一些嘲讽的味道。但我认为，“逼格”应该是一种大隐隐于市的淡定，一种出淤泥而不染的清高，一种观望世事变迁而不为之动容的气质，一种身处外部世界的混乱却依然能听从内部世界的召唤的能力。<br><a id="more"></a><br>你觉得我这番解释是装逼也无所谓，因为我的理想一直以来就是做一个有逼格的人。</p>
<p>追求逼格的过程不是一蹴而就的，更不是一劳永逸的，而更像是逆水行舟，一刻都万万不可以松懈。忍不住让我想起柏邦妮说过的一句话：“哪有什么胜利可言，挺住就是一切。”</p>
<p>所以，追求逼格可以被看做是一种坚持不懈的抗争，一种保护内部世界的完整饱足而不被外部世界侵蚀的抗争。这种抗争，本身就足以令人肃然起敬。如此看来，逼格恰恰存在于追求逼格的过程之中。</p>
<p>保护内部世界之完整饱足的方法有很多，而我独爱写作。我一直信奉，虽然不是每个人都可以把写作当成自己的职业，但所有人都一定可以把写作当成自己的一种状态。</p>
<p>在我眼中，世间的写作不过两种，对内的和对外的。今天来聊聊我理想中的写作吧。</p>
<p>对内的写作，是内部世界在巩固自己的版图，是往下扎根。典型的形式包括写日记——你是作者，你也是唯一的读者。如果，你在落笔的当下决定，读者除了你自己还可以包括其他人，即使再少数的其他人都好，那都不能被归为“对内的写作”了。当然，如果你已经完成了写作的这个部分，只不过在之后的阅读过程中觉得，公布出来被他人看见也无妨，那又另当别论。这里讨论的，只是写作这个动作进行之时的内心向度。</p>
<p>对内的写作应该是繁杂凌乱的、忠诚于自己所念所想的，应该完完全全原汁原味地呈现一个自由的内心世界，所以没有必要进行自我审查。想起以前学摄影的时候，教授叮嘱我们拿起相机就一定要无所顾忌、疯狂地拍，把照片导出来之后才开始进行筛选，千万不要把创作和编辑的过程混在一块儿，千万不要在拍的时候就缩手缩脚，或者直接在相机上删掉所谓的不满意的照片。同理，对内的写作应该是零编辑、只关注在创作之上的，这是至关重要的资本原始积累，所以格局一定要大。</p>
<p>对内的写作是一个认识自己的过程，所以要诚实地面对内心的所有情感，尤其是那些不足为外人道也的阴暗的部分。比如说，跟你走得很近的人里有一个你很鄙视的人，但是你又不得不装作和ta相处起来很愉快，那你不妨可以在对内的写作过程中梳理这种情感。挖掘自己的邪恶天赋，并承认它们，是帮助自己成长为一个丰富的人的必经之路。</p>
<p>对内的写作也是一个用来讨好自己的过程。在我以前还很热衷于写日记的时候，我的日记本是一本红色软皮抄。我喜欢它封面的颜色，更喜欢它米色的空白内页。内页纸张的触感很好，而且不会晕墨，真的是难能可贵的品质。我喜欢用墨蓝或者深绿的墨水写日记，尤其喜欢用英雄616钢笔。偏好的场所包括图书馆的静音区和自己的房间。我尤其喜欢物理意义上的下笔，虽然有的时候也在电脑上写日记，但总感觉动笔的信息量更大，毕竟笔迹可以直白地展示当时的心理状态，而且我总喜欢看自己在不同时期的笔迹的变化。这些癖好让我觉得对内的写作是一种仪式，是一种褒奖，是一种可以独享的时光。那本红色软皮抄用完之后我仿佛丧失了写日记的兴趣，因为再也没有找到媲美它的日记本了，不得不说，很可惜。</p>
<p>对外的写作，是内部世界朝外部的扩张。我个人主张它必须是功利的。所谓功利，是指功效和实用性，说直白一点就是，既然你选择了对外写作，就应该对你传播的这些信息负责，让它们尽可能高效地被读者所接收。所以对外的写作应该是方便理解的、易于消化的。要呈现这种特性，在对外写作的过程中就务必有相当一部分的精力花在编辑之上。如果说对内的写作单纯需要用心，对外的写作则更需要用脑。</p>
<p>写到这里，不得不提写作与朗读之间的密不可分的关系。</p>
<p>我在上写作课的时候，教授给我们讲过这样一个有趣的故事。说是有一个写作界的大神，看人很准，曾经试过一连好几年的普利策获奖者都是他曾经相中过表扬过的新人。于是有人去问大神，他眼光为什么这么厉害。大神说，我去编辑部里面看啊，看到那些写稿子的时候嘴里在念念有词的人，我就知道他们有戏了。</p>
<p>教授给我们讲这个故事，意图是要让我们爱上朗读自己的作品，不但如此，更要用朗读的方式去体会其他优秀的写作。朗读，实际上是一场非常严肃的检阅。从编辑方面的效用来看，在朗读的过程中，很容易就能挑出错别字、语病、累赘用词等等小毛病，也可以发现段落间逻辑衔接有没有跳脱这样的结构上的问题。</p>
<p>曾经有人评价我的行文是轻松的、不费力的，大概也是因为我总是以口语化的要求来规范自己的写作吧。也有人曾经给我提意见说，你能不能不要念，专心写，因为你的文笔远胜于你的口头表达，要念出来的话等于限制了你文采的发挥。我当然承认，为了口语化理念的贯彻，不得不让渡出一部分高深的辞藻和逻辑。但口语化的理念可以让写作者更多地采用主谓宾的语序，减少繁杂的修饰语，抛弃冗长的句式结构，实际上是一种更生活、更亲近的表达方式。这种亲近可以让写作者的内部世界建立与外部世界友好的交流，而信息的顺畅流通恰好又可以维持一个更饱满鲜活的内部世界。出于这种理念，我个人也非常不喜欢故作傲慢和刻意艰涩的写作，总让人感到一种封闭和敌意。</p>
<p>我本科的最后一年花了整整两个学期在上写作课，但结果却是对写作像一个新朋友一样。 我并不恐慌，相反的，我对这个变化感到无比的兴奋。想到之前写作课教授给我们援引过的一句话，那是美国著名诗人、作家卡尔·桑德堡在72岁的时候说的： </p>
<blockquote>
<p>I’m still studying verbs and the mystery of how they connect nouns. I am more suspicious of adjectives than at any other time in all my born days. “我仍旧在学习动词，以及它们和名词连接的奥秘。现在的我比任何时候都更怀疑形容词。” </p>
</blockquote>
<p>就像是一个幼儿园小朋友在堆积木的时候的有趣的发现。真是一种有美感的状态。</p>
<p>我希望，我也能活出那样的一天。</p>
<p>转自新浪微博 <em><a href="http://weibo.com/rainfieldfifi" target="_blank" rel="external">@恢复吃素的F小姐。</a></em></p>
<p>说一个我认为最有逼格的故事吧：<br>某日跟某死党微信对话如下:<br><img src="/2017/02/10/为了保持逼格，不要停止写作/../../../../images/W1.png" alt=""><img src="/2017/02/10/为了保持逼格，不要停止写作/../../../../images/W2.png" alt=""><img src="/2017/02/10/为了保持逼格，不要停止写作/../../../../images/W3.png" alt=""></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="240" src="//music.163.com/outchain/player?type=0&id=600358672&auto=0&height=430"></iframe>



]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“逼格”一词，网络上常见的解释是“装逼的格调”，听起来有一些嘲讽的味道。但我认为，“逼格”应该是一种大隐隐于市的淡定，一种出淤泥而不染的清高，一种观望世事变迁而不为之动容的气质，一种身处外部世界的混乱却依然能听从内部世界的召唤的能力。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="杂文" scheme="http://lzrlizhirong.github.io/categories/%E6%9D%82%E6%96%87/"/>
    
    
      <category term="写作" scheme="http://lzrlizhirong.github.io/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>ES-5.0.2-学习(2)——Kibana+X-Pack介绍使用</title>
    <link href="http://lzrlizhirong.github.io/2017/02/09/ES-5-0-2-%E5%AD%A6%E4%B9%A0-1-%E2%80%94%E2%80%94Kibana-X-Pack%E4%BB%8B%E7%BB%8D%E4%BD%BF%E7%94%A8/"/>
    <id>http://lzrlizhirong.github.io/2017/02/09/ES-5-0-2-学习-1-——Kibana-X-Pack介绍使用/</id>
    <published>2017-02-09T11:20:34.000Z</published>
    <updated>2017-02-14T06:40:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>Kibana是一个为 ElasticSearch 提供的数据分析的 Web 接口。可使用它对日志进行高效的搜索、可视化、分析等各种操作。Kibana目前最新的版本5.0.2，回顾一下Kibana 3和Kibana 4的界面。<br>下面的图展示的是Kibana 3的界面，所有的仪表盘直接放置主页。<br><img src="/2017/02/09/ES-5-0-2-学习-1-——Kibana-X-Pack介绍使用/../../../../images/e21.png" alt=""><br><a id="more"></a><br>下面的图展示的是Kibana 4的界面，和Kibana 3最大的区别是将原来的主体分成三个部分，分别是发现页、可视化、仪表盘。<br><img src="/2017/02/09/ES-5-0-2-学习-1-——Kibana-X-Pack介绍使用/../../../../images/e22.png" alt=""><br>下面是目前Kibana 5最新版本的界面。相比较Kibana 4除了界面的风格变化，最主要是功能栏上添加了Timeline、Management和Dev Tools选项。<br><img src="/2017/02/09/ES-5-0-2-学习-1-——Kibana-X-Pack介绍使用/../../../../images/e23.png" alt=""></p>
<h1 id="Discover"><a href="#Discover" class="headerlink" title="Discover"></a>Discover</h1><blockquote>
<p><em>You can interactively explore your data from the Discover page. You have access to every document in every index that matches the selected index pattern. You can submit search queries, filter the search results, and view document data. You can also see the number of documents that match the search query and get field value statistics. If a time field is configured for the selected index pattern, the distribution of documents over time is displayed in a histogram at the top of the page.</em></p>
</blockquote>
<p>从发现页可以交互地探索ES的数据。可以访问与所选索引模式相匹配的每一个索引中的每一个文档。您可以提交搜索查询、筛选搜索结果和查看文档数据。还可以看到匹配搜索查询和获取字段值统计的文档的数量。如果一个时间字段被配置为所选择的索引模式，则文档的分布随着时间的推移显示在页面顶部的直方图中。<br><img src="/2017/02/09/ES-5-0-2-学习-1-——Kibana-X-Pack介绍使用/../../../../images/e24.png" alt=""></p>
<h1 id="Visualize"><a href="#Visualize" class="headerlink" title="Visualize"></a>Visualize</h1><blockquote>
<p>Visualize enables you to create visualizations of the data in your Elasticsearch indices. You can then build dashboards that display related visualizations.Kibana visualizations are based on Elasticsearch queries. By using a series of Elasticsearch aggregations to extract and process your data, you can create charts that show you the trends, spikes, and dips you need to know about.You can create visualizations from a search saved from Discover or start with a new search query.</p>
</blockquote>
<p>可视化能使你创造你的Elasticsearch指标数据的可视化。然后你可以建立仪表板显示相关的可视化。Kibana的可视化是基于Elasticsearch查询。通过一系列的Elasticsearch聚合提取和处理您的数据，您可以创建图表显示你需要知道的关于趋势，峰值和骤降。您可以从搜索保存的搜索中创建可视化或从一个新的搜索查询开始。<br><img src="/2017/02/09/ES-5-0-2-学习-1-——Kibana-X-Pack介绍使用/../../../../images/e25.png" alt=""></p>
<h1 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h1><blockquote>
<p>A Kibana dashboard displays a collection of saved visualizations. You can arrange and resize the visualizations as needed and save dashboards so they be reloaded and shared.</p>
</blockquote>
<p>一个仪表板显示Kibana保存的一系列可视化。你可以根据需要安排和调整可视化，并保存仪表盘，可以被加载和共享。<br><img src="/2017/02/09/ES-5-0-2-学习-1-——Kibana-X-Pack介绍使用/../../../../images/e26.png" alt=""></p>
<h1 id="Monitoring"><a href="#Monitoring" class="headerlink" title="Monitoring"></a>Monitoring</h1><p>从图中可以发现，默认Kibana是没有该选项的。其实，Monitoring是由X-Pack集成提供的。</p>
<blockquote>
<p>The X-Pack monitoring components enable you to easily monitor Elasticsearch through Kibana. You can view cluster health and performance in real time as well as analyze past cluster, index, and node metrics. In addition, you can monitor the performance of Kibana itself.When you install X-Pack on your cluster, a monitoring agent runs on each node to collect and index metrics from Elasticsearch. With X-Pack installed in Kibana, you can then view the monitoring data through a set of specialized dashboards.</p>
</blockquote>
<p>该X-pack监控组件使您可以通过Kibana轻松地监控ElasticSearch。您可以实时查看集群的健康和性能，以及分析过去的集群、索引和节点度量。此外，您可以监视Kibana本身性能。当你安装X-pack在群集上，监控代理运行在每个节点上收集和指数指标从Elasticsearch。安装在X-pack在Kibana上，您可以查看通过一套专门的仪表板监控数据。<br>回顾安装过程：<a href="https://lzrlizhirong.github.io/2017/02/09/ES-5-0-2-%E5%AD%A6%E4%B9%A0-1-%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85Elasticsearch%E3%80%81Kibana%E5%92%8CX-Pack/">ES-5-0-2-学习-1-——安装Elasticsearch、Kibana和X-Pack/</a>，可以发现，在安装X-pack的时候分别在ElasticSearch根目录和Kibana根目录下操作。<br><img src="/2017/02/09/ES-5-0-2-学习-1-——Kibana-X-Pack介绍使用/../../../../images/e27.png" alt=""></p>
<h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><blockquote>
<p>The X-Pack graph capabilities enable you to discover how items in an Elasticsearch index are related. You can explore the connections between indexed terms and see which connections are the most meaningful. This can be useful in a variety of applications, from fraud detection to recommendation engines.For example, graph exploration could help you uncover website vulnerabilities that hackers are targeting so you can harden your website. Or, you might provide graph-based personalized recommendations to your e-commerce customers.X-Pack provides a simple, yet powerful graph exploration API, and an interactive graph visualization tool for Kibana. Both work with out of the box with existing Elasticsearch indices—you don’t need to store any additional data to use the X-Pack graph features.</p>
</blockquote>
<p>X-Pack图的能力使你发现一个Elasticsearch索引项是如何相关联的。你可以探索索引条款之间的连接，看看哪些连接是最有意义的。从欺诈检测到推荐引擎，对各种应用中这都是有用的，例如，图的探索可以帮助你发现网站上黑客的目标的漏洞，所以你可以硬化你的网站。或者，您可以为您的电子商务客户提供基于图表的个性化推荐。X-pack提供简单，但功能强大的图形开发API，和Kibana交互式图形可视化工具。使用X-pack图有工作与开销与现有Elasticsearch指标你不需要任何额外的数据存储的特征。<br><img src="/2017/02/09/ES-5-0-2-学习-1-——Kibana-X-Pack介绍使用/../../../../images/e28.png" alt=""></p>
<h1 id="Timelion"><a href="#Timelion" class="headerlink" title="Timelion"></a>Timelion</h1><blockquote>
<p>Timelion is a time series data visualizer that enables you to combine totally independent data sources within a single visualization. It’s driven by a simple expression language you use to retrieve time series data, perform calculations to tease out the answers to complex questions, and visualize the results.</p>
</blockquote>
<p>Timelion是一个时间序列数据的可视化，可以结合在一个单一的可视化完全独立的数据源。它是由一个简单的表达式语言驱动的，你用来检索时间序列数据，进行计算，找出复杂的问题的答案，并可视化的结果。<br>这个功能由一系列的功能函数组成，同样的查询的结果，也可以通过Dashboard显示查看。<br><img src="/2017/02/09/ES-5-0-2-学习-1-——Kibana-X-Pack介绍使用/../../../../images/e29.png" alt=""></p>
<h1 id="Management"><a href="#Management" class="headerlink" title="Management"></a>Management</h1><blockquote>
<p>The Management application is where you perform your runtime configuration of Kibana, including both the initial setup and ongoing configuration of index patterns, advanced settings that tweak the behaviors of Kibana itself, and the various “objects” that you can save throughout Kibana such as searches, visualizations, and dashboards.This section is pluginable, so in addition to the out of the box capabitilies, packs such as X-Pack can add additional management capabilities to Kibana.<br>管理中的应用是在你执行你的运行时配置kibana，包括初始设置和指标进行配置模式，高级设置，调整自己的行为和Kibana，各种“对象”，你可以查看保存在整个Kibana的内容如发现页，可视化和仪表板。<br>这部分是pluginable，除此之外，X-pack可以给Kibana增加额外的管理能力。<br>You can use X-Pack Security to control what Elasticsearch data users can access through Kibana.When you install X-Pack, Kibana users have to log in. They need to have the kibana_user role as well as access to the indices they will be working with in Kibana.If a user loads a Kibana dashboard that accesses data in an index that they are not authorized to view, they get an error that indicates the index does not exist. X-Pack Security does not currently provide a way to control which users can load which dashboards.</p>
</blockquote>
<p>你可以使用X-pack安全控制哪些用户可以访问Elasticsearch数据通过Kibana。当你安装X-pack，Kibana用户登录。他们需要有kibana_user作用以及获得的指标，他们将在Kibana的工作。如果用户加载Kibana仪表板，访问数据的一个索引，他们未被授权查看，他们得到一个错误，表明指数不存在。X-pack安全目前并不提供一种方法来控制哪些用户可以负荷的仪表板。<br><img src="/2017/02/09/ES-5-0-2-学习-1-——Kibana-X-Pack介绍使用/../../../../images/e210.png" alt=""></p>
<h1 id="Dev-Tools"><a href="#Dev-Tools" class="headerlink" title="Dev Tools"></a>Dev Tools</h1><p>原先的交互式控制台Sense，使用户方便的通过浏览器直接与Elasticsearch进行交互。从Kibana 5开始改名并直接内建在Kibana，就是Dev Tools选项。<br>注意如果是Kibana 5以上，不能通过以下命令安装Sense。(踩过的坑)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kibana plugin --install elastic/sense</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kibana-plugin install elastic/sense instead</div></pre></td></tr></table></figure></p>
<p><img src="/2017/02/09/ES-5-0-2-学习-1-——Kibana-X-Pack介绍使用/../../../../images/e211.png" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>内容比较简单，主要是对Kibana工具的整体功能总结，方便接下来对ElasticSearch 5的学习，其中X-Pack主要是添加身份权限的验证，以及原先需要安装其他各种Marvel、Hand等各种功能插件添加到Kibana上使用才能使用的功能。<br>学习链接：<br>X-Pack：<a href="https://www.elastic.co/guide/en/x-pack/current/xpack-introduction.html" target="_blank" rel="external">https://www.elastic.co/guide/en/x-pack/current/xpack-introduction.html</a><br>Kibana：<a href="https://www.elastic.co/guide/en/kibana/current/introduction.html" target="_blank" rel="external">https://www.elastic.co/guide/en/kibana/current/introduction.html</a></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="240" src="//music.163.com/outchain/player?type=0&id=600358672&auto=0&height=430"></iframe>



<p>出处：<a href="http://www.cnblogs.com/wxw16/p/6156335.html" target="_blank" rel="external">http://www.cnblogs.com/wxw16/p/6156335.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kibana是一个为 ElasticSearch 提供的数据分析的 Web 接口。可使用它对日志进行高效的搜索、可视化、分析等各种操作。Kibana目前最新的版本5.0.2，回顾一下Kibana 3和Kibana 4的界面。&lt;br&gt;下面的图展示的是Kibana 3的界面，所有的仪表盘直接放置主页。&lt;br&gt;&lt;img src=&quot;/2017/02/09/ES-5-0-2-学习-1-——Kibana-X-Pack介绍使用/../../../../images/e21.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://lzrlizhirong.github.io/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://lzrlizhirong.github.io/tags/Elasticsearch/"/>
    
      <category term="kibana" scheme="http://lzrlizhirong.github.io/tags/kibana/"/>
    
      <category term="x-pack" scheme="http://lzrlizhirong.github.io/tags/x-pack/"/>
    
  </entry>
  
  <entry>
    <title>Markdown——入门指南</title>
    <link href="http://lzrlizhirong.github.io/2017/02/09/Markdown%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://lzrlizhirong.github.io/2017/02/09/Markdown——入门指南/</id>
    <published>2017-02-09T09:48:48.000Z</published>
    <updated>2017-02-14T06:39:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导语："><a href="#导语：" class="headerlink" title="导语："></a>导语：</h1><p>Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。</p>
<p><img src="/2017/02/09/Markdown——入门指南/../../../../images/1.png" alt="1"><br><a id="more"></a></p>
<h1 id="一、认识-Markdown"><a href="#一、认识-Markdown" class="headerlink" title="一、认识 Markdown"></a>一、认识 Markdown</h1><p>在刚才的导语里提到，Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。目前来看，支持 Markdown 语法的编辑器有很多，包括很多网站（例如简书）也支持了 Markdown 的文字录入。Markdown 从写作到完成，导出格式随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式，这种格式写出的简历更能得到 HR 的好感。甚至可以利用 CloudApp 这种云服务工具直接上传至网页用来分享你的文章，全球最大的轻博客平台 Tumblr，也支持 Mou 这类 Markdown 工具的直接上传。</p>
<h3 id="Markdown-官方文档"><a href="#Markdown-官方文档" class="headerlink" title="Markdown 官方文档"></a>Markdown 官方文档</h3><p>这里可以看到官方的 Markdown 语法规则文档，当然，后文我也会用自己的方式阐述这些语法的具体用法。</p>
<ul>
<li><em><a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">创始人 John Gruber 的 Markdown 语法说明</a></em></li>
<li><em><a href="http://wowubuntu.com/markdown/#list" target="_blank" rel="external">Markdown 中文版语法说明</a></em></li>
</ul>
<h3 id="使用-Markdown-的优点"><a href="#使用-Markdown-的优点" class="headerlink" title="使用 Markdown 的优点"></a>使用 Markdown 的优点</h3><ul>
<li>专注你的文字内容而不是排版样式，安心写作。</li>
<li>轻松的导出 HTML、PDF 和本身的 .md 文件。</li>
<li>纯文本内容，兼容所有的文本编辑器与字处理软件。</li>
<li>随时修改你的文章版本，不必像字处理软件生成若干文件版本导致混乱。</li>
<li>可读、直观、学习成本低。</li>
</ul>
<h3 id="使用-Markdown-的误区"><a href="#使用-Markdown-的误区" class="headerlink" title="使用 Markdown 的误区"></a>使用 Markdown 的误区</h3><blockquote>
<p><em>We believe that writing is about content, about what you want to say – not about fancy formatting.<br>    我们坚信写作写的是内容，所思所想，而不是花样格式。<br>    — Ulysses for Mac</em></p>
</blockquote>
<ul>
<li>Markdown 旨在简洁、高效，也由于 Markdown 的易读易写，人们用不同的编程语言实现了多个版本的解析器和生成器，这就导致了目前不同的 Markdown 工具集成了不同的功能（基础功能大致相同），例如流程图与时序图，复杂表格与复杂公式的呈现，虽然功能的丰富并没有什么本质的缺点，但终归有些背离初衷，何况在编写的过程中很费神，不如使用专业的工具撰写来的更有效率，所以如果你需实现复杂功能，专业的图形界面工具会更加方便。<strong>当然，如果你对折腾这些不同客户端对 Markdown 的定制所带来高阶功能感到愉悦的话，那也是无可厚非的。</strong></li>
</ul>
<h1 id="二、Markdown-语法的简要规则"><a href="#二、Markdown-语法的简要规则" class="headerlink" title="二、Markdown 语法的简要规则"></a>二、Markdown 语法的简要规则</h1><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><img src="/2017/02/09/Markdown——入门指南/../../../../images/2.png" alt="标题"><br>标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。</p>
<blockquote>
<p>#一级标题</p>
<p>##二级标题</p>
<p>###三级标题</p>
</blockquote>
<p>以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。<br><img src="/2017/02/09/Markdown——入门指南/../../../../images/3.jpeg" alt=""></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>如果你需要引用一小段别处的句子，那么就要用引用的格式。<br>只需要在文本前加入 &gt; 这种尖括号（大于号）即可<br><img src="/2017/02/09/Markdown——入门指南/../../../../images/34.jpeg" alt=""></p>
<h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><p><img src="/2017/02/09/Markdown——入门指南/../../../../images/5.jpeg" alt=""><br>注：使用markdown写文章，插入图片的格式为图片名称，这里要说的是链接地址怎么写。<br>对于hexo，有两种方式：<br>使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。<br>使用微博图床，地址<a href="http://weibotuchuang.sinaapp.com/，将图片拖入区域中，会生成图片的URL，这就是链接地址。" target="_blank" rel="external">http://weibotuchuang.sinaapp.com/，将图片拖入区域中，会生成图片的URL，这就是链接地址。</a></p>
<h3 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h3><p>Markdown 的粗体和斜体也非常简单，用两个 <em> 包含一段文本就是粗体的语法，用一个 </em> 包含一段文本就是斜体的语法。<br>例如：<strong>这里是粗体</strong> <em>这里是斜体</em> </p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格是我觉得 Markdown 比较累人的地方，例子如下：<br><img src="/2017/02/09/Markdown——入门指南/../../../../images/7.png" alt=""><br>这种语法生成的表格如下：<br><img src="/2017/02/09/Markdown——入门指南/../../../../images/6.png" alt=""></p>
<h3 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h3><p>如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 <code>把中间的代码包裹起来。</code>this is code`<br><img src="/2017/02/09/Markdown——入门指南/../../../../images/8.jpeg" alt=""><br>使用 tab 键即可缩进。</p>
<h3 id="块代码"><a href="#块代码" class="headerlink" title="块代码"></a>块代码</h3><p>两种方式<br>1.代码每一行的前面都加4个空格或一个tab<br>2.第一行和最后一行都是3个，中间的行是代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">this is code block 1</div><div class="line">this is code block 2</div></pre></td></tr></table></figure></p>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>分割线的语法只需要三个 * 号，例如：</p>
<hr>
<h1 id="三、相关推荐"><a href="#三、相关推荐" class="headerlink" title="三、相关推荐:"></a>三、相关推荐:</h1><p>图床工具用来上传图片获取 URL 地址</p>
<ul>
<li><a href="http://droplr.com/" target="_blank" rel="external">Droplr</a></li>
<li><a href="http://www.getcloudapp.com/" target="_blank" rel="external">Cloudapp</a></li>
<li><a href="https://itunes.apple.com/cn/app/yi-xiang/id672522335?mt=12&amp;uo=4" target="_blank" rel="external">ezShare for Mac</a></li>
<li><a href="http://weibotuchuang.sinaapp.com/" target="_blank" rel="external">围脖图床修复计划</a></li>
</ul>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="240" src="//music.163.com/outchain/player?type=0&id=600358672&auto=0&height=430"></iframe>





]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;导语：&quot;&gt;&lt;a href=&quot;#导语：&quot; class=&quot;headerlink&quot; title=&quot;导语：&quot;&gt;&lt;/a&gt;导语：&lt;/h1&gt;&lt;p&gt;Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2017/02/09/Markdown——入门指南/../../../../images/1.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Markdown" scheme="http://lzrlizhirong.github.io/categories/Markdown/"/>
    
    
      <category term="MarkDown" scheme="http://lzrlizhirong.github.io/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>ES-5.0.2-学习(1)——安装Elasticsearch、Kibana和X-Pack</title>
    <link href="http://lzrlizhirong.github.io/2017/02/09/ES-5-0-2-%E5%AD%A6%E4%B9%A0-1-%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85Elasticsearch%E3%80%81Kibana%E5%92%8CX-Pack/"/>
    <id>http://lzrlizhirong.github.io/2017/02/09/ES-5-0-2-学习-1-——安装Elasticsearch、Kibana和X-Pack/</id>
    <published>2017-02-09T08:39:09.000Z</published>
    <updated>2017-02-14T06:40:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装准备："><a href="#安装准备：" class="headerlink" title="安装准备："></a>安装准备：</h1><p>安装Elasticsearch唯一的要求是安装官方新版的Java，包括对应的Jdk。</p>
<h1 id="安装Elasticsearch"><a href="#安装Elasticsearch" class="headerlink" title="安装Elasticsearch"></a>安装Elasticsearch</h1><p>首先到官网下载最新版本的Elasticsearch压缩包。<br>可以使用命令，注意将最新的可用的下载链接填入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/  elasticsearch-5.0.2.zip</div><div class="line">unzip elasticsearch-5.0.2.zip</div><div class="line">cd elasticsearch-5.0.2</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="运行Elasticsearch"><a href="#运行Elasticsearch" class="headerlink" title="运行Elasticsearch"></a>运行Elasticsearch</h1><p>Elasticsearch已经准备就绪，执行以下命令可在前台启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/elasticsearch</div></pre></td></tr></table></figure></p>
<p>如果想在后台以守护进程模式运行，添加-d参数。<br>打开另一个终端进行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &apos;http://localhost:9200/?pretty&apos;</div></pre></td></tr></table></figure></p>
<p>你能看到以下返回信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;name&quot;: &quot;vP19PMO&quot;,</div><div class="line">&quot;cluster_name&quot;: &quot;elasticsearch&quot;,</div><div class="line">&quot;cluster_uuid&quot;: &quot;IMKMfkMsSrKODIYg5gxgeQ&quot;,</div><div class="line">&quot;version&quot;: &#123;</div><div class="line">    &quot;number&quot;: &quot;5.0.2&quot;,</div><div class="line">    &quot;build_hash&quot;: &quot;f6b4951&quot;,</div><div class="line">    &quot;build_date&quot;: &quot;2016-11-24T10:07:18.101Z&quot;,</div><div class="line">    &quot;build_snapshot&quot;: false,</div><div class="line">    &quot;lucene_version&quot;: &quot;6.2.1&quot;</div><div class="line">&#125;,</div><div class="line">&quot;tagline&quot;: &quot;You Know, for Search&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这说明你的ELasticsearch集群已经启动并且正常运行。</p>
<h1 id="安装Kiabna"><a href="#安装Kiabna" class="headerlink" title="安装Kiabna"></a>安装Kiabna</h1><p>Kibana是一个为 ElasticSearch 提供的数据分析的 Web 接口。可使用它对日志进行高效的搜索、可视化、分析等各种操作。<br>首先到官网下载最新版本的Kiabna压缩包。<br>可以使用如下命令，注意将最新的可用的下载链接填入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-5.1.1-linux-x86_64.tar.gz</div><div class="line">sha1sum kibana-5.1.1-linux-x86_64.tar.gz</div><div class="line">tar -xzf kibana-5.1.1-linux-x86_64.tar.gz</div><div class="line">cd kibana/</div></pre></td></tr></table></figure></p>
<p>注意：<br><em><a href="https://www.elastic.co/downloads/kibana" target="_blank" rel="external">https://www.elastic.co/downloads/kibana</a> 可以在该地址获取下载链接，一定要选择对于系统和版本。
</em>按照文档的要求，一般情况下kibana的版本必须和Elasticsearch安装的版本一致。</p>
<h1 id="安装X-Pack"><a href="#安装X-Pack" class="headerlink" title="安装X-Pack"></a>安装X-Pack</h1><p>X-Pack是一个Elastic Stack的扩展，将安全，警报，监视，报告和图形功能包含在一个易于安装的软件包中。在Elasticsearch 5.0.0之前，您必须安装单独的Shield，Watcher和Marvel插件才能获得在X-Pack中所有的功能。</p>
<h2 id="下载前提"><a href="#下载前提" class="headerlink" title="下载前提"></a>下载前提</h2><p>Elasticsearch 5.0.2<br>Kibana 5.0.2</p>
<h2 id="Elasticsearch下载X-Pack"><a href="#Elasticsearch下载X-Pack" class="headerlink" title="Elasticsearch下载X-Pack"></a>Elasticsearch下载X-Pack</h2><p>在Es的根目录（每个节点），运行 <em>bin/elasticsearch-plugin</em> 进行安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/elasticsearch-plugin install x-pack/Users/root/Downloads/markdown/763363-20161209181135163-1294099591.png</div></pre></td></tr></table></figure></p>
<p><img src="/2017/02/09/ES-5-0-2-学习-1-——安装Elasticsearch、Kibana和X-Pack/../../../../images/e1.png" alt=""><br>安装过程中跳出选项现在y即可。<br>如果你在Elasticsearch已禁用自动索引的创建，在<em>elasticsearch.yml</em>配置<em>action.auto_create_index</em>允许X-pack创造以下指标：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">action.auto_create_index: .security,.monitoring*,.watches,.triggered_watches,.watcher-history*</div></pre></td></tr></table></figure></p>
<p>运行Elasticsearch。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/elasticsearch</div></pre></td></tr></table></figure></p>
<h2 id="Kibana下载X-Pack"><a href="#Kibana下载X-Pack" class="headerlink" title="Kibana下载X-Pack"></a>Kibana下载X-Pack</h2><p>在Kibana根目录运行 <em>bin/kibana-plugin</em> 进行安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kibana-plugin install x-pack/Users/root/Downloads/markdown/1.png</div></pre></td></tr></table></figure></p>
<p><img src="/2017/02/09/ES-5-0-2-学习-1-——安装Elasticsearch、Kibana和X-Pack/../../../../images/e2.png" alt=""><br>安装过程会比较久，耐心等待。<br>运行Kibana。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kibana</div></pre></td></tr></table></figure></p>
<h2 id="验证X-Pack"><a href="#验证X-Pack" class="headerlink" title="验证X-Pack"></a>验证X-Pack</h2><p>在浏览器上输入：<em><a href="http://localhost:5601/" target="_blank" rel="external">http://localhost:5601/</a></em> ，可以打开Kibana，此时需要输入用户名和密码登录，默认分别是 <em>elastic</em> 和 <em>changeme</em>。</p>
<h1 id="安装参考："><a href="#安装参考：" class="headerlink" title="安装参考："></a>安装参考：</h1><p><em>每个操作系统安装Elasticsearch的文件选择不同，参考：<a href="https://www.elastic.co/downloads/elasticsearch，选择对应的文件下载。" target="_blank" rel="external">https://www.elastic.co/downloads/elasticsearch，选择对应的文件下载。</a>
</em>安装Kiabna需要根据操作系统做选择，参考：<a href="https://www.elastic.co/guide/en/kibana/current/install.html，选择对应的文件下载。" target="_blank" rel="external">https://www.elastic.co/guide/en/kibana/current/install.html，选择对应的文件下载。</a><br>*安装X-Pack需要根据Elasticsearch安装不同的方式提供不同的安装方法，参考：<a href="https://www.elastic.co/guide/en/x-pack/5.0/installing-xpack.html#installing-xpack。" target="_blank" rel="external">https://www.elastic.co/guide/en/x-pack/5.0/installing-xpack.html#installing-xpack。</a></p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>在刚接触Elasticsearch的时候，会有很多名词不能理解，或者不知道其中的关系。其中很多是为不同版本的Elasticsearch而存在的。</p>
<h2 id="Marvel"><a href="#Marvel" class="headerlink" title="Marvel"></a>Marvel</h2><p>Marvel插件：在簇中从每个节点汇集数据。这个插件必须每个节点都得安装。<br>Marvel是Elasticsearch的管理和监控工具，在开发环境下免费使用。它包含了Sense。</p>
<h2 id="Sense"><a href="#Sense" class="headerlink" title="Sense"></a>Sense</h2><p>交互式控制台，使用户方便的通过浏览器直接与Elasticsearch进行交互。</p>
<h2 id="Hand"><a href="#Hand" class="headerlink" title="Hand"></a>Hand</h2><p>在学习Elasticsearch的过程中，必不可少需要通过一些工具查看es的运行状态以及数据。如果都是通过rest请求，未免太过麻烦，而且也不够人性化。此时，Head插件可以实现基本信息的查看，rest请求的模拟，数据的检索等等。</p>
<h2 id="X-pack"><a href="#X-pack" class="headerlink" title="X-pack"></a>X-pack</h2><p>x-pack是elasticsearch的一个扩展包，将安全，警告，监视，图形和报告功能捆绑在一个易于安装的软件包中，也是官方推荐的。</p>
<h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><p>kibana是一个与elasticsearch一起工作的开源的分析和可视化的平台。使用kibana可以查询、查看并与存储在elasticsearch索引的数据进行交互操作。使用kibana能执行高级的数据分析，并能以图表、表格和地图的形式查看数据。<br>kibana使得理解大容量的数据变得非常容易。它非常简单，基于浏览器的接口使我们能够快速的创建和分享显示elasticsearch查询结果实时变化的仪表盘。<br><strong><em>在Elasticsearch 5版本之前，一般都是通过安装Kibana，而后将Marvel、Hand等各种功能插件添加到Kibana上使用。在Elasticsearch 5版本之后，一般情况下只需要安装一个官方推荐的X-pack扩展包即可。</em></strong></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="240" src="//music.163.com/outchain/player?type=0&id=600358672&auto=0&height=430"></iframe>



<p>出处：<a href="http://www.cnblogs.com/wxw16/p/6150681.html" target="_blank" rel="external">http://www.cnblogs.com/wxw16/p/6150681.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装准备：&quot;&gt;&lt;a href=&quot;#安装准备：&quot; class=&quot;headerlink&quot; title=&quot;安装准备：&quot;&gt;&lt;/a&gt;安装准备：&lt;/h1&gt;&lt;p&gt;安装Elasticsearch唯一的要求是安装官方新版的Java，包括对应的Jdk。&lt;/p&gt;
&lt;h1 id=&quot;安装Elasticsearch&quot;&gt;&lt;a href=&quot;#安装Elasticsearch&quot; class=&quot;headerlink&quot; title=&quot;安装Elasticsearch&quot;&gt;&lt;/a&gt;安装Elasticsearch&lt;/h1&gt;&lt;p&gt;首先到官网下载最新版本的Elasticsearch压缩包。&lt;br&gt;可以使用命令，注意将最新的可用的下载链接填入：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/  elasticsearch-5.0.2.zip&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;unzip elasticsearch-5.0.2.zip&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cd elasticsearch-5.0.2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://lzrlizhirong.github.io/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://lzrlizhirong.github.io/tags/Elasticsearch/"/>
    
      <category term="kibana" scheme="http://lzrlizhirong.github.io/tags/kibana/"/>
    
      <category term="x-pack" scheme="http://lzrlizhirong.github.io/tags/x-pack/"/>
    
  </entry>
  
</feed>
